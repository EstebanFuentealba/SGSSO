
<!-- saved from url=(0055)http://www.sommarskog.se/dynamic_sql.html#sp_executesql -->
<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<title>The curse and blessings of dynamic SQL</title>
<style type="text/css">
<!--
.allcaps {font-size: 90%;}

h2 {border-top: 2px dashed black;
    padding-top: 12pt;}

li {margin-bottom: 3 pt;
    margin-left: -10pt;}


pre {margin-left: 18pt;}



-->
</style>

</head>

<body>

<h1 align="center">The Curse and Blessings of Dynamic SQL</h1>
<p align="left"><font size="-1">An SQL text by <a href="http://www.sommarskog.se/index.html">Erland Sommarskog</a>,
SQL Server MVP. <a href="http://www.sommarskog.se/dynamic_sql.html#revisions">Latest revision</a>: 2011-06-23.</font></p>
<p align="left"><font size="-1">An earlier version of this article is
   also available in
   <a href="http://www.insidesql.org/beitraege/entwicklung/dynamisches-sql-fluch-und-segen">German</a>. Translations
   provided by SQL Server MVP Frank Kalis.</font></p>
<h2 align="left">Introduction</h2>
<p align="left">If you follow the various newsgroups on Microsoft <small class="allcaps">SQL</small> Server,
you often see people asking why they can't do:</p>
<pre>SELECT * FROM @tablename
SELECT @colname FROM tbl
SELECT * FROM tbl WHERE x IN (@list)</pre>
<p>For all three examples you can expect someone to answer <i>Use dynamic <small class="allcaps">SQL</small></i>
   and give a quick example on how to do it. Unfortunately, for all three examples
   above, dynamic <small class="allcaps">SQL</small> is a poor solution.
   On the other hand, there are situations where dynamic <small class="allcaps">SQL</small>
   is the best or only way to go. </p>
<p align="left">In this article I will discuss the use of dynamic <small class="allcaps">SQL</small>
   in stored procedures and to a minor extent from client languages. To set the
   scene, I start with a very quick overview on application
   architecture for data access. I then proceed to describe the feature dynamic
   <small class="allcaps">SQL</small> as such,
   with a quick introduction followed by the gory syntax details. Next, I continue with a discussion on <small class="allcaps">SQL</small> injection, a
   security issue that it is essential to have good understanding of when
   you work with dynamic <small class="allcaps">SQL</small>. This is followed by a section where I discuss why
   we use stored procedures, and how that is affected by the use of dynamic <small class="allcaps">SQL</small>.
   I carry on with a section on good practices and tips for writing
   dynamic <small class="allcaps">SQL</small>. I conclude by reviewing a number of
   situations where you could use dynamic <small class="allcaps">SQL</small> and
   whether it is a good or bad idea to do it.</p>
<p align="left">The article covers all versions of <small class="allcaps">SQL</small> Server from <small class="allcaps">SQL</small>&nbsp;6.5 to
   <small class="allcaps">SQL</small>&nbsp;2008, with emphasis on <small class="allcaps">SQL</small>&nbsp;2000 and later
versions. </p>

<h4>Contents:</h4>
<contents>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#forks">Accessing Data from an Application</a></b><br>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#Introducing">Introducing Dynamic <small class="allcaps">SQL</small></a></b><br>
<small style="font-size: 90%">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#FirstEncounter">A First Encounter</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="./The curse and blessings of dynamic SQL_files/The curse and blessings of dynamic SQL.htm">sp_executesql</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#EXEC4"><nobr>EXEC()</nobr></a><br>
</small>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#SQL_injection"><small class="allcaps">SQL</small> Injection – a Serious Security Issue</a></b><br>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#storedprocedures">Dynamic <small class="allcaps">SQL</small> and Stored Procedures</a></b><br>
<small style="font-size: 90%">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#permissions">The Permission System</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#queryplans">Caching Query Plans</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#networktraffic">Reducing Network Traffic</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#encapsulation">Encapsulating Logic</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#trackability">Keeping Track of what Is Used</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#easiness">Ease of Writing SQL Code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#supportability">Addressing Bugs and Problems</a><br>
</small>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#good_practices">Good Coding Practices and Tips for Dynamic <small class="allcaps">SQL</small></a></b><br>
<small style="font-size: 90%">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#debugprints">Use Debug Prints!</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#nestedstrings">Nested Strings</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#formatting">Spacing and Formatting</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#objectnames">Dealing with Dynamic Table and Column Names</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#quotestring">Quotename, Nested Strings and Quotestring</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#QUOTED_IDENTIFIER">QUOTED_IDENTIFIER</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#sp_executesqlong">sp_executesql and Long SQL Strings in SQL 2000</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#UDF">Dynamic SQL in User-Defined Functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#cursor0">Cursors and Dynamic SQL</a><br>
</small>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#EXECatlinked"><small class="allcaps"><nobr>EXEC()</nobr></small> at Linked Server</a></b><br>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#Common_cases">Common Cases when to (Not) Use Dynamic <small class="allcaps">SQL</small></a></b><br>
<small style="font-size: 90%">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Dyn_table">SELECT * FROM @tablename</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Sales_yymm">SELECT * FROM sales + @yymm</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Dyn_update">UPDATE tbl SET @colname = @value WHERE keycol = @keyval</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.sommarskog.se/dynamic_sql.html#columnalias">SELECT col AS @myname</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Dyn_DB">SELECT * FROM @dbname + '..tbl'</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#List">SELECT * FROM tbl WHERE col IN (@list)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Condition">SELECT * FROM tbl WHERE @condition</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Dyn_search">Dynamic Search Conditions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Crosstab">Dynamic Crosstab</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Order_by">SELECT * FROM tbl ORDER BY @col</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Top">SELECT TOP @n FROM tbl</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Cre_tbl">CREATE TABLE @tbl</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#unknowncolumns">CREATE TABLE with Unknown Columns</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#linkservers">Linked Servers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#OPENQUERY">OPENQUERY</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#Col_width">Dynamic Column Widths</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.sommarskog.se/dynamic_sql.html#maintenancetasks">Dynamic SQL and Maintenance Tasks</a><br>
</small>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#Feedback">Acknowledgements and Feedback</a></b><br>
&nbsp;&nbsp;&nbsp;<b><a href="http://www.sommarskog.se/dynamic_sql.html#revisions">Revision History</a></b>
</contents>
<p>Note: many of
   the code samples in this text works against the <b>pubs</b> and <b>Northwind</b> databases
   that ship with <small class="allcaps">SQL</small>&nbsp;2000 and <small class="allcaps">SQL</small>&nbsp;7, but not with <small class="allcaps">SQL</small>&nbsp;2005
and later. You can download
   these databases from
   <a href="http://www.microsoft.com/downloads/info.aspx?na=22&p=1&SrcDisplayLang=en&SrcCategoryId=&SrcFamilyId=&u=/downloads/details.aspx?FamilyID=06616212-0356-46a0-8da2-eebc53a68034&DisplayLang=en">
   Microsoft's web site</a>. <br>

</p>

<h2><a name="forks">Accessing Data from an Application</a></h2>
<p>Before I describe dynamic <small class="allcaps">SQL, I</small> like to briefly discuss the various ways you can
   access data from an application to give an overview of what I'll be
   talking about in this article.</p>
<p>(<b>Note</b>: all through this text I will
   refer to <i>client</i> as anything that accesses <small class="allcaps">SQL</small> Server from the outside.
   In the overall application architecture that may in fact be a middle tier or
   a business layer, but as that is of little interest to this article, I use <i>
   client</i> in the sake of brevity.) </p>
<p>There are two main roads to go, and then there are forks and sub-forks.</p>
<ol type="1">
   <li>Send <small class="allcaps">SQL</small> statements from the client to <small class="allcaps">SQL</small>
      Server.
   <ol type="a">
       <li>Rely on <small class="allcaps">SQL</small> generated by the client <small class="allcaps">API</small>, using options like
          <b>CommandType</b>.<b>TableDirect</b> and methods like .<b>Update</b>. <small class="allcaps">LINQ</small> falls into this group as well.</li>
       <li>Compose the <small class="allcaps">SQL</small> strings in the client code.
       <ol type="i">
          <li>Build the entire <small class="allcaps">SQL</small> string with parameter values expanded.</li>
          <li>Use parameterised queries.</li>
       </ol></li>
   </ol></li>
   <li>Perform access through stored procedures.</li>
   <ol type="a">
       <li>Stored procedures in <small class="allcaps"><nobr>T-SQL</nobr></small></li>
       <ol type="i">
         <li>Use static <small class="allcaps">SQL</small> only.</li>
         <li>Use dynamic <small class="allcaps">SQL</small> together with static <small class="allcaps">SQL</small>.</li>
       </ol>
       <li>Stored procedures in a <small class="allcaps">CLR</small> language such as C# or VB .Net. (<small class="allcaps">SQL</small>&nbsp;2005
          and later.)</li>
   </ol>
</ol>
<p>Fork <nobr>1-a</nobr> may be good for simple tasks, but you are likely to
   find that you outgrow it as the complexity of your application increases.
   In any case, this approach falls entirely outside the scope of this article.</p>
<p>Many applications are built along the principles of fork <nobr>1-b</nobr>,
   and as long as you take the sub-fork <nobr>1-b-ii</nobr>, it does not have to
   be bad. (Why <nobr>1-b-i</nobr> is bad, is
   something I will come back to. Here I will just drop two keywords:
   <a href="http://www.sommarskog.se/dynamic_sql.html#SQL_injection"><small class="allcaps">SQL</small>
   Injection</a> and <a href="http://www.sommarskog.se/dynamic_sql.html#queryplans">Query-Plan Reuse</a>.) Nonetheless, in many shops the mandate is
   that you should use stored procedures. When you use stored procedures with
   only static <small class="allcaps">SQL</small>, users do
   not need direct permissions to access the tables, only permissions to execute the stored
   procedures, and thus you can use the stored procedure to control what users
   may and may not do.</p>
<p>The main focus for this text is sub-fork <nobr>2-a-ii</nobr>. When used
   appropriately, dynamic <small class="allcaps">SQL</small> in stored
   procedures can be a powerful addition to static <small class="allcaps">SQL</small>. But some of the questions on the newsgroups leads to
   dynamic <small class="allcaps">SQL</small> in stored procedures that are so meaningless, that these people
   would be better off with fork <nobr>1-b</nobr> instead.</p>
<p>Finally, fork <nobr>2-b</nobr>, stored procedures in the <small class="allcaps">CLR</small>, is in many
   regards very similar to fork <nobr>1-b</nobr>, since all data access from <small class="allcaps">CLR</small>
   procedures is through generated <small class="allcaps">SQL</small> strings, parameterised or unparameterised. If you have settled on <small class="allcaps">SQL</small>
   procedures for your application, there is little point in rewriting them into
   the <small class="allcaps">CLR</small>. However, <small class="allcaps">CLR</small> code can be a valuable supplement for tasks that are
   difficult to perform in <small class="allcaps"><nobr>T-SQL</nobr></small>, but you yet want to perform server-side. </p>
<h2><a name="Introducing">Introducing Dynamic SQL</a></h2>
<p>In this chapter I will first look at some quick examples of dynamic <small class="allcaps">SQL</small> and
   point out some very important implications of using dynamic <small class="allcaps">SQL</small>. I will then
   describe <b>sp_executesql</b> and <small class="allcaps"><nobr>EXEC()</nobr></small> in detail, the two commands you can use to
   invoke dynamic <small class="allcaps">SQL</small> from <small class="allcaps"><nobr>T-SQL</nobr></small>.</p>
<h3><a name="FirstEncounter">A First Encounter</a></h3>
<p>Understanding dynamic <small class="allcaps">SQL</small> itself is not difficult. Au contraire, it's rather
   too easy to use. Understanding the fine details, though, takes a little
   longer time. If you start out using dynamic <small class="allcaps">SQL</small> casually, you are bound to face
   accidents when things do not work as you have anticipated.</p>
<p>One of the problems
 listed in the introduction was how to write a stored procedure that takes a
   table name as its input. Here are two examples, based on the two ways to do dynamic <small class="allcaps">SQL</small> in
   Transact-<small class="allcaps">SQL</small>:</p>
<pre>CREATE PROCEDURE general_select1 @tblname sysname,
                                 @key     varchar(10) AS
DECLARE @sql nvarchar(4000)
SELECT @sql = ' SELECT col1, col2, col3 ' +
              ' FROM dbo.' + quotename(@tblname) +
              ' WHERE keycol = @key'
EXEC sp_executesql @sql, N'@key varchar(10)', @key</pre>
<pre>CREATE PROCEDURE general_select2 @tblname nvarchar(127),
                                 @key     varchar(10) AS
EXEC('SELECT col1, col2, col3
      FROM ' + @tblname + '
      WHERE keycol = ''' + @key + '''')</pre>
<p>Before I say anything else, permit me to point out that these are examples of
   <i><b>bad</b></i> usage of dynamic <small class="allcaps">SQL</small>.
   Passing a table name as a parameter
   is not how you should write stored procedures, and one aim of this article is
   to explain this in detail. Also, the two examples are not equivalent. While
   both examples are bad, the second
   example has several problems that the first does not have. What these
   problems are will be apparent as you read this text.</p>
<p>Whereas the above looks very simple and easy, there are some very important things
   to observe. The first thing is permissions. You may know that when you
   use stored procedures, users do not need permissions to access the tables accessed by the stored procedure. <b><i>This does not apply when
   you use dynamic <small class="allcaps">SQL</small>!</i></b> For the procedures above to execute
   successfully, the users must have <small class="allcaps">SELECT</small> permission on the table in @tblname. In <small class="allcaps">SQL</small>&nbsp;2000 and earlier this is an absolute rule with no
   way around it. <small class="allcaps">Starting with SQL</small>&nbsp;2005, there are alternatives, something I will
   come
   back to in the section <i><a href="http://www.sommarskog.se/dynamic_sql.html#permissions">The Permission System</a></i>.</p>
<p>Next thing to observe is that the dynamic <small class="allcaps">SQL</small> <b><i>is not part of
   the stored procedure</i></b>, but constitutes <i><b>its own scope</b></i>. Invoking a block
   of dynamic <small class="allcaps">SQL</small> is akin to call a nameless stored procedure created ad-hoc. This
   has a number of consequences:</p>
<ul>
  <li>Within the block of dynamic <small class="allcaps">SQL</small>, you cannot access local variables
     (including table variables) or parameters of the calling stored procedure.
     But you can pass parameters – in and out – to a block of dynamic <small class="allcaps">SQL</small> if you
     use <b>sp_executesql</b>.</li>
  <li>Any <small class="allcaps">USE</small> statement in the dynamic <small class="allcaps">SQL</small> will not affect the calling stored procedure.</li>
  <li>Temp tables created in the dynamic <small class="allcaps">SQL</small> will not be accessible from the
    calling procedure since they are dropped when the dynamic <small class="allcaps">SQL</small> exits.
     (Compare to how temp tables created in a stored procedure go away when you
     exit the procedure.) The block of
     dynamic <small class="allcaps">SQL</small> can however access temp tables created
     by the calling procedure.</li>
  <li>If you issue a <small class="allcaps">SET</small> command in the dynamic <small class="allcaps">SQL</small>, the effect of the <small class="allcaps">SET</small>
     command lasts for the duration of the block of dynamic <small class="allcaps">SQL</small>
     only and does not affect the caller.</li>
  <li> The query plan for the stored procedure does not include the dynamic <small class="allcaps">SQL.
     T</small>he block of dynamic <small class="allcaps">SQL</small> has a query plan of its own.</li>
</ul>
<p>As you've seen there are two ways to invoke dynamic <small class="allcaps">SQL</small>, <b>sp_executesql</b> and
   <small class="allcaps"><nobr>EXEC()</nobr></small>. <b>sp_executesql</b> was added in <small class="allcaps">SQL</small>&nbsp;7, whereas <small class="allcaps"><nobr>EXEC()</nobr></small> has been around
   since <small class="allcaps">SQL</small>&nbsp;6.0. In application code, <b>sp_executesql</b> should be your choice 95%
   of the time for reasons that will prevail. For now I will only give two
   keywords: <a href="http://www.sommarskog.se/dynamic_sql.html#SQL_injection"><small class="allcaps">SQL</small> Injection</a> and
   <a href="http://www.sommarskog.se/dynamic_sql.html#queryplans">Query-Plan Reuse</a>. <small class="allcaps"><nobr>EXEC()</nobr></small> is mainly useful for quick throw-away things and <small class="allcaps">DBA</small> tasks, but also
   comes to the rescue in <small class="allcaps">SQL</small>&nbsp;2000 and <small class="allcaps">SQL</small>&nbsp;7
   when the <small class="allcaps">SQL</small> string exceeds 4000 characters. And, obviously, in <small class="allcaps">SQL</small>&nbsp;6.5, <small class="allcaps"><nobr>EXEC()</nobr></small> is the sole choice. In the next
   two sections we will look at these two commands in detail.</p>

<h3><a name="sp_executesql">sp_executesql</a></h3>
<p><b>sp_executesql</b> is a built-in stored procedure that takes two
   pre-defined parameters and any number of user-defined parameters. </p>
<p>The first parameter <b>@stmt</b> is mandatory, and contains a batch of one or
 more <small class="allcaps">SQL</small> statements. The data type of @stmt is <b>ntext</b> in <small class="allcaps">SQL</small>&nbsp;7 and <small class="allcaps">SQL</small>&nbsp;2000,
 and <b>nvarchar(<small class="allcaps">MAX</small>)</b> in <small class="allcaps">SQL</small>&nbsp;2005 and later. Beware that you must pass an <b>nvarchar</b>/<b>ntext</b>
 value (that is, a Unicode value). A <b>varchar</b> value won't do. </p>
<p>The second parameter <b>@params</b> is optional, but you will use it 90% of the
 time. @params declares the parameters that you refer to in @stmt. The syntax
 of @params is exactly the same as for the parameter list of a stored procedure. The
   parameters can
 have default values and they can have the <small class="allcaps">OUTPUT</small> marker. Not all parameters you declare must actually
   appear in the <small class="allcaps">SQL</small> string. (Whereas all variables that appear in the <small class="allcaps">SQL</small>
   string must be declared, either with a <small class="allcaps">DECLARE</small> inside @stmt, or in
   @params.) Just like @stmt, the data
 type of @params is <b>ntext</b> <small class="allcaps">SQL</small>&nbsp;2000 and earlier and <b>nvarchar(<small class="allcaps">MAX</small>)</b>
since <small class="allcaps">SQL</small>&nbsp;2005.</p>
<p>The rest of the parameters are simply the parameters that you declared in
 @params, and you pass them as you pass parameters to a stored procedure, either
 positional or named. To get a value back from your output parameter, you must
   specify <small class="allcaps">OUTPUT</small> with the parameter, just like when you call a stored
   procedure. Note that the first two parameters, @stmt and @params, must be specified positionally. You
   can provide the parameter names for them, but these names are blissfully ignored.</p>
<p>Let's look at an example. Say that in your database, many tables
 have a column <i>LastUpdated</i>, which holds the time a row last was
 updated. You want to be able to find out how many rows in each table that were modified at
 least once during a period. This is not something you run as part of the application, but
   something you run as a <small class="allcaps">DBA</small> from time to time, so you just keep it as a script
   that you have a around. Here is what it could look like:</p>
<pre>DECLARE @tbl    sysname,
        <b>@sql    nvarchar(4000),
        @params nvarchar(4000)</b>,
        @count  int

DECLARE tblcur CURSOR STATIC LOCAL FOR
   SELECT object_name(id) FROM syscolumns WHERE name = 'LastUpdated'
   ORDER  BY 1
OPEN tblcur

WHILE 1 = 1
BEGIN
   FETCH tblcur INTO @tbl
   IF @@fetch_status &lt;&gt; 0
      BREAK

   <b>SELECT @sql =
   N' SELECT @cnt = COUNT(*) FROM dbo.' + quotename(@tbl) +
   N' WHERE LastUpdated BETWEEN @fromdate AND ' +
   N'                           coalesce(@todate, ''99991231'')'
   SELECT @params = N'@fromdate datetime, ' +
                    N'@todate   datetime = NULL, ' +
                    N'@cnt      int      OUTPUT'
   EXEC sp_executesql @sql, @params, '20060101', @cnt = @count OUTPUT
</b>
   PRINT @tbl + ': ' + convert(varchar(10), @count) + ' modified rows.'
END

DEALLOCATE tblcur</pre>
<p>I've put the lines that pertain directly to the dynamic <small class="allcaps">SQL</small> in bold face. You
   can see that I have declared the @sql and @params variables to be of the maximum
   length for <b>nvarchar</b> variables in <small class="allcaps">SQL</small>&nbsp;2000. In <small class="allcaps">SQL</small>&nbsp;2005
and later, you may want to make it a routine to
   declare @sql as <b>nvarchar(<small class="allcaps">MAX</small>)</b>, more about this just below. </p>
<p>When I assign the @sql variable, I am careful to format the statement so that
   it is easy to read, and I leave in spaces to avoid that two concatenated
   parts are glued together without space in between, which could cause a syntax
   error. I put the table name in
   <a href="http://www.sommarskog.se/dynamic_sql.html#objectnames"><nobr><b>quotename()</b></nobr></a> in case a table name has any special
   characters in it. I also prefix the table name with "<b>dbo</b>.", which is a good habit, as we will see when we look at dynamic <small class="allcaps">SQL</small> and
   <a href="http://www.sommarskog.se/dynamic_sql.html#queryplans">query plans</a>. Overall, I will cover this sort of
   <a href="http://www.sommarskog.se/dynamic_sql.html#good_practices">good practices</a> more in detail later in the text. Note also the appearance of <b>
   <code>''</code></b> around the date literal – the rule in <small class="allcaps"><nobr>T-SQL</nobr></small> is that to include the string
   delimiter in a string, you must double it.</p>
<p>In this example, the dynamic <small class="allcaps">SQL</small> has three parameters: one mandatory input
   parameter, one optional input parameter, and one
   output parameter. I've assumed that this time the <small class="allcaps">DBA</small> wanted to see
   all changes made after 2006-01-01, which is why I've left out @todate in the call
   to <b>sp_executesql</b>. Since I left out one variable, I must specify the last,
   @cnt by name – the same rules as when you call a stored procedure. Note also
   that the variable is called @cnt in the dynamic <small class="allcaps">SQL</small>, but @count in the
   surrounding script. Normally, you might want to use the same name, but I
   wanted to stress that the @cnt in the dynamic <small class="allcaps">SQL</small> is only visible within the
   dynamic <small class="allcaps">SQL</small>, whereas @count is <b><i>not</i></b> visible there.</p>
<p>You may note that I've prefix the string literals with <b>N</b> to denote that
   they are Unicode strings. As @sql and @params are declared as <b>nvarchar</b>,
   technically this is not necessary (as long as you stick to your 8-bit character
   set). However, when you provide any of the strings directly in the call to
   <b>sp_executesql</b>, you must specify the N, as in this fairly silly example:</p>
<pre>EXEC sp_executesql N'SELECT @x', N'@x int', @x = 2</pre>
<p>If you remove any of the <b>N</b>s, you will get an error message. Since <b>sp_executesql</b> is a built-in stored procedure, there is no implicit
   conversion from <b>varchar</b>.</p>
<p>You may wonder why I do not pass @tbl as a parameter as well. The answer is
   that you can't. Dynamic <small class="allcaps">SQL</small> is just like any other <small class="allcaps">SQL</small>. You can't specify a
   table name through a variable in <small class="allcaps"><nobr>T-SQL</nobr></small>, that's the whole story. Thus, when you
   need to specify things like table names, column names etc dynamically,
   you must interpolate them into the string.</p>
<p>If you are on <small class="allcaps">SQL</small>&nbsp;2000 or <small class="allcaps">SQL</small>&nbsp;7, there is a limitation with <b>sp_executesql</b>
   when it comes to the length of the <small class="allcaps">SQL</small> string. While the parameter is <b>ntext</b>,
   you cannot use this data type for local variables. Thus, you will have to
   stick to <b>nvarchar(4000)</b>. In many cases this will do fine, but it is not
   uncommon to exceed that limit. In this case, you will need to use <small class="allcaps"><nobr>EXEC()</nobr></small>,
   described just below.</p>
<p>Since <small class="allcaps">SQL</small>&nbsp;2005, this is not an issue. Here you can use the new data type
 <b>nvarchar(<small class="allcaps">MAX</small>)</b> which can hold as much data as <b>ntext</b>,
   but without the many restrictions of <b>ntext</b>.</p>
<h3><a name="EXEC4"><nobr>EXEC()</nobr></a></h3>

<p><small class="allcaps"><nobr>EXEC()</nobr></small> takes one parameter which is an <small class="allcaps">SQL</small> statement to
   execute. The parameter can be a concatenation of
   string variables and string literals, but cannot include calls to functions
   or other operators. For very simple
   cases, <small class="allcaps"><nobr>EXEC()</nobr></small> is less hassle than <b>sp_executesql</b>. For instance, say that you
   want to run <small class="allcaps">UPDATE STATISTICS WITH FULLSCAN</small> on some selected tables. It could
   look like this:</p>
<pre>FETCH tblcur INTO @tbl
IF @@fetch_status &lt;&gt; 0 BREAK
EXEC('UPDATE STATISTICS [' + @tbl + '] WITH FULLSCAN')</pre>
<p>In the example with <b>sp_executesql</b>, I used <nobr><b>quotename()</b></nobr>, but here I've let it
   suffice with adding brackets, in case there is a table named <b>Order
   Details</b> (which there is in the <b>Northwind</b> database). Since <small class="allcaps">EXEC</small> only permits
   string literals and string variables to be concatenated and not arbitrary
   expressions, this is not legal:</p>
<pre>EXEC('UPDATE STATISTICS ' + <font color="#FF0000">quotename(@tbl)</font> + ' WITH FULLSCAN')</pre>
<p>Best practice is to always use a variable to hold the <small class="allcaps">SQL</small> statement, so the
   example would better read:</p>
<pre>FETCH tblcur INTO @tbl
IF @@fetch_status &lt;&gt; 0 BREAK
SELECT @sql = 'UPDATE STATISTICS ' + quotename(@tbl) + ' WITH FULLSCAN'
EXEC(@sql)</pre>
<p>The fact that you can concatenate strings within <small class="allcaps"><nobr>EXEC()</nobr></small> permits you to
   make very quick things, which can be convenient at times, but it can lead to
   poor habits in application code. However, there are situations where this is an
   enormous blessing. As I mentioned, in <small class="allcaps">SQL</small>&nbsp;7 and <small class="allcaps">SQL</small>&nbsp;2000, you can in practice
   only use 4000 characters in your <small class="allcaps">SQL</small> string with <b>sp_executesql</b>. <small class="allcaps">EXEC</small> does
   not have this limitation, since you can say:</p>
<pre>EXEC(@sql1 + @sql2 + @sql3)</pre>
<p>Where all of @sql1, @sql2 and @sql3 can be 4000 characters long – or even
   8000 characters as <small class="allcaps"><nobr>EXEC()</nobr></small> permits you to use <b>varchar</b>.</p>
<p>Since you cannot use parameters, you cannot as easily get values out from
   <small class="allcaps"><nobr>EXEC()</nobr></small> as you can with <b>sp_executesql</b>. You can, however, use <small class="allcaps">INSERT-EXEC</small>
   to insert the result set from <small class="allcaps"><nobr>EXEC()</nobr></small> into a table. I will show you an example
   <a href="http://www.sommarskog.se/dynamic_sql.html#sp_executesqlong">later on</a>, when I also show you how you can
   use <small class="allcaps"><nobr>EXEC()</nobr></small> to pass longer strings than 4000 characters to <b>sp_executesql</b>.</p>
<p>In <small class="allcaps">SQL</small>&nbsp;2005 and later, <small class="allcaps"><nobr>EXEC()</nobr></small> permits impersonation so that you can say:</p>
<pre>EXEC(@sql) AS USER = 'mitchell'
EXEC(@sql) AS LOGIN = 'CORDOBA\Miguel'</pre>
<p>This is mainly a syntactical shortcut that saves you from embedding the
   invocation of dynamic <small class="allcaps">SQL</small> in <small class="allcaps">EXECUTE AS</small> and <small class="allcaps">REVERT. (I</small> discuss these
   statements more in detail in my article <i>
   <a href="http://www.sommarskog.se/grantperm.html#EXECASstatement">Granting Permissions Through Stored
   Procedures</a></i>.)</p>
<p><small class="allcaps">SQL</small>&nbsp;2005 adds a valuable extension to <small class="allcaps"><nobr>EXEC()</nobr></small>: you can use
   it to execute
   strings on <a href="http://www.sommarskog.se/dynamic_sql.html#EXECatlinked">linked servers</a>. I will cover this form
   of <small class="allcaps"><nobr>EXEC()</nobr></small> in a separate section
   later in this text. </p>
<h2><a name="Security2"></a><a name="SQL_injection">SQL Injection – a Serious Security Issue</a></h2>
<p>Before you start to use dynamic <small class="allcaps">SQL</small> all over town, you need to learn about <i>
   <small class="allcaps">SQL</small> injection </i>and how you protect your application against it. <small class="allcaps">SQL</small>
   injection is a technique whereby an intruder enters data that causes your application
   to execute <small class="allcaps">SQL</small> statements you did not intend it to. <small class="allcaps">SQL</small> injection is possible as soon there is dynamic <small class="allcaps">SQL</small> which is
   handled carelessly, be that <small class="allcaps">SQL</small> statements sent from the client, dynamic <small class="allcaps">SQL</small>
   generated in <small class="allcaps"><nobr>T-SQL</nobr></small> stored procedures, or <small class="allcaps">SQL</small> batches executed from <small class="allcaps">CLR</small> stored
   procedures. This is not a line of attack that is unique to
   <small class="allcaps">MS SQL</small> Server, but all <small class="allcaps">RDBMS</small> are open to it.</p>
<p>Here is an example. The purpose of the procedure below is to permit users to
   search for orders by various conditions. A real-life example of such a
   procedure would have many more parameters, but I've cut it down to two to be
   brief. (This is, by the way, a problem for which dynamic <small class="allcaps">SQL</small> is a very good
   solution.) As the procedure is written, it is open for <small class="allcaps">SQL</small> injection:</p>
<pre>CREATE PROCEDURE search_orders @custid   nchar(5)     = NULL,
                               @shipname nvarchar(40) = NULL AS
DECLARE @sql nvarchar(4000)
SELECT @sql = ' SELECT OrderID, OrderDate, CustomerID, ShipName ' +
              ' FROM dbo.Orders WHERE 1 = 1 '
IF @custid IS NOT NULL
   SELECT @sql = @sql + ' AND CustomerID LIKE ''' + @custid + ''''
IF @shipname IS NOT NULL
   SELECT @sql = @sql + ' AND ShipName LIKE ''' + @shipname + ''''
EXEC(@sql)</pre>
<p>Before we look at a real attack, let's just discuss this from the point of view
   of user-friendliness. Assume that the input for the parameters @custid and @shipname comes directly
   from the user and a naïve and innocent user wants to look for orders where <b>ShipName</b> is <i>Let's Stop N Shop</i>, so he enters <i>Let's</i>. Do you see
   what will happen? Because @shipname includes a single quote, he will get a
   syntax error. So even if you think that <small class="allcaps">SQL</small> injection is no issue to you,
   because you trust your users, you still need to read this section, so that they
   can search for Brian O'Brien and Samuel Eto'o. </p>
<p>So this is the starting point. A delimiter, usually a single quote, affects your dynamic <small class="allcaps">SQL</small>, and
   a malicious user
   can take benefit of this. For
   instance, consider this input for @shipname:</p>
<pre>' DROP TABLE Orders --</pre>
<p>The resulting <small class="allcaps">SQL</small> becomes:</p>
<pre>SELECT * FROM dbo.Orders WHERE 1 = 1  AND ShipName LIKE '' <font color="#FF0000">DROP TABLE orders</font> --'</pre>
 <p>This is a perfectly legal batch of <small class="allcaps"><nobr>T-SQL</nobr></small>, including the text in red. Since there is something called permissions in <small class="allcaps">SQL</small> Server, this
    attack may or may not succeed. A plain
    user who runs a Windows application and who logs into <small class="allcaps">SQL</small> Server with his
    own login, is not likely to have
    permissions to drop a table. But it is not uncommon for web applications to
    have a general login that runs <small class="allcaps">SQL</small> queries on behalf of the users. And if this web app logs into <small class="allcaps">SQL</small> Server with <b>sysadmin</b> or <b>db_owner</b>
    privileges, the attack succeeds. Mind you, with <b>sysadmin</b> rights, the
    attacker can add users and logins as he pleases. And if the service account
    for <small class="allcaps">SQL</small> Server has admin privileges in Windows, the attacker has access into
    your network far beyond <small class="allcaps">SQL</small> Server through <b>xp_cmdshell</b>. (Which is
    disabled by default on <small class="allcaps">SQL</small>&nbsp;2005 and later, but if the attacker has achieved
    <b>sysadmin</b> rights on the server, he can change that.)</p>
<p>Typically, an attacker first tests what happens
   if he enters a single quote (<code>'</code>) in an input field or a <small class="allcaps">URL</small>. If this
   yields a syntax error, the attacker knows that there is a vulnerability. He
   then finds out if he needs any extra tokens to terminate the query, and then
   he can add his own <small class="allcaps">SQL</small> statement. Finally he adds a comment character to kill
   the rest of the <small class="allcaps">SQL</small> string to avoid syntax errors. Single quote is the most
   common character to reveal openings for <small class="allcaps">SQL</small> injection, but if you have
   dynamic table and column names, there are more options an attacker could
   succeed with.
   Take this dreadful version of <b>general_select</b>:</p>
<pre>CREATE PROCEDURE general_select2 @tblname nvarchar(127),
                                 @key     varchar(10) AS
EXEC('SELECT col1, col2, col3
      FROM ' + @tblname + '
      WHERE keycol = ''' + @key + '''')</pre>
<p>and assume that @tblname comes from a <small class="allcaps">URL</small>. There are quite some options that
   an attacker could use to take benefit of this hole. </p>
<p>And don't overlook numeric values: they can very well be used for <small class="allcaps">SQL</small>
   injection. Of course, in a <small class="allcaps"><nobr>T-SQL</nobr></small> procedure where the value is passed as an
   <b>int</b> parameter there is no risk, but if a supposedly numeric value is directly
   interpolated into an <small class="allcaps">SQL</small> string in client code, there is a huge potential for
   <small class="allcaps">SQL</small> injection.</p>
<p>Keep in mind that user input comes from more places than just input fields on
   a form. The most commonly used area for injection attacks on the Internet is
   probably parameters in URLs and cookies. Thus, be very careful how you handle
   anything that comes into&nbsp; your application from the outside.</p>
<p>You may think that it takes not only skill, but also luck for someone to find
   and exploit a hole for <small class="allcaps">SQL</small> injection. But remember that there are too many hackers out there
   with too much time on their hands. <small class="allcaps">SQL</small> injection is a serious security issue, and you
   must take precautions to protect your applications against it.</p>
<p>One approach I seen mentioned from time to time, is to validate input data in some way, but in my opinion that is not
the right way to go. Here are are the three steadfast
   principles you need to follow:</p>
<ul>
   <li>Never run with more privileges than necessary. Users that log into an
      application with their own login should normally only have <small class="allcaps">EXEC</small>
      permissions on stored procedures. If you use dynamic <small class="allcaps">SQL</small>, it should be
      confined to reading operations so that users only need <small class="allcaps">SELECT</small> permissions.
      A web site that logs into a database should not have any elevated
      privileges, preferably only <small class="allcaps">EXEC</small> and
      (maybe) <small class="allcaps">SELECT</small> permissions. Never let the web site log in as <b>sa</b>!</li>
   <li>For web applications: never expose error messages from <small class="allcaps">SQL</small> Server to the
      end user.</li>
   <li><i><b>Always used
      parameterised statements.</b></i> That is, in a <small class="allcaps"><nobr>T-SQL</nobr></small> procedure use <b>sp_executesql</b>,
      not <small class="allcaps"><nobr>EXEC()</nobr></small>. </li>
</ul>
<p>The first point is mainly a safeguard, so that if there is a injection hole,
   the intruder will not be able to do that much harm. The second point makes
   the task for the attacker more difficult as he cannot get feedback from his
   attempts.</p>
<p>But it is the third point that is the
   actual protection, and that we will look a little closer at. The procedure <b>search_orders</b> above should be coded as:</p>
<pre>CREATE PROCEDURE search_orders @custid   nchar(5) = NULL,
                               @shipname nvarchar(40) = NULL AS
DECLARE @sql nvarchar(4000)
SELECT @sql = ' SELECT OrderID, OrderDate, CustomerID, ShipName ' +
              ' FROM dbo.Orders WHERE 1 = 1 '
IF @custid IS NOT NULL
   SELECT @sql = @sql + ' AND CustomerID LIKE @custid '
IF @shipname IS NOT NULL
   SELECT @sql = @sql + ' AND ShipName LIKE @shipname '
EXEC sp_executesql @sql, N'@custid nchar(5), @shipname nvarchar(40)',
                   @custid, @shipname</pre>
<p>Since the <small class="allcaps">SQL</small> string does not include any user input, there is
   <i><b>no</b></i> opening for <small class="allcaps">SQL</small>
   injection. It's as simple as that. By the way, note that since we can include
   parameters in the parameter list, even if they don't actually appear in the
   <small class="allcaps">SQL</small> string, we don't need any complicated logic to build the parameter list,
   but can keep it static. In the same vein, we can always pass all input
   parameters to the <small class="allcaps">SQL</small> string.</p>
<p>As you may recall, you cannot pass everything as parameters to dynamic <small class="allcaps">SQL</small>,
   for instance table and column names. In this case you must enclose all such
   object names in <nobr><b>quotename()</b></nobr>, that I will return to in the section <i>
   <a href="http://www.sommarskog.se/dynamic_sql.html#good_practices">Good Coding Practices and Tips for Dynamic <small class="allcaps">SQL</small></a></i>.</p>
<p>The example above was for dynamic <small class="allcaps">SQL</small> in a <small class="allcaps"><nobr>T-SQL</nobr></small> stored procedure. The same advice
   applies to <small class="allcaps">SQL</small> generated in client code or in a <small class="allcaps">CLR</small> stored procedure. Since
   this is so important, here is an example of coding the above in VB6 and <small class="allcaps">ADO</small>:</p>
<pre>Set cmd = CreateObject("ADODB.Command")
Set cmd.ActiveConnection = cnn

cmd.CommandType = adCmdText
cmd.CommandText = " SELECT OrderID, OrderDate, CustomerID, ShipName " &amp; _
                  " FROM dbo.Orders WHERE 1 = 1 "
If custid &lt;&gt; "" Then
   cmd.CommandText = cmd.CommandText &amp; " AND CustomerID LIKE ? "
   cmd.Parameters.Append
      cmd.CreateParameter("@custid", adWChar, adParamInput, 5, custid)
End If

If shipname &lt;&gt; "" Then
   cmd.CommandText = cmd.CommandText &amp; " AND ShipName LIKE ? "
   cmd.Parameters.Append cmd.CreateParameter("@shipname", _
                         adVarWChar, adParamInput, 40, shipname)
End If

Set rs = cmd.Execute</pre>
<p>Since the main focus of this text is dynamic <small class="allcaps">SQL</small> in <small class="allcaps"><nobr>T-SQL</nobr></small> procedures, I will
   explain this example only briefly. In <small class="allcaps">ADO</small> you use <code>?</code> as a parameter
   marker, and you can only pass parameters that
   actually appear in the <small class="allcaps">SQL</small> string. (If you
   specify too many parameters, you will get a completely incomprehensible error
   message.) If you use the <small class="allcaps">SQL</small> Profiler to see what <small class="allcaps">ADO</small>
   sends to <small class="allcaps">SQL</small> Server, you will find that it invokes – <b>sp_executesql</b>.</p>
<p>Protection against <small class="allcaps">SQL</small> injection is not the only advantage of using
   parameterised queries. In the section <i><a href="http://www.sommarskog.se/dynamic_sql.html#queryplans">Caching Query
   Plans</a></i>, we will look more in detail on parameterised queries and at a
   second very important reason to use them. This section also includes an example of composing and sending a parameterised <small class="allcaps">SQL</small> statement for SqlClient
   in VB .Net.</p>
<p>You may think that an even better protection against <small class="allcaps">SQL</small> injection is to use
   stored procedures with static <small class="allcaps">SQL</small> only. Yes, this is true, <b>
   <i>but</i>!</b> It
   depends on how you call your stored procedures from the client. If you
   compose an <small class="allcaps">EXEC</small> command into which you interpolate the input values, you are
   back on square one and you are as open to <small class="allcaps">SQL</small> injection as ever.
   In <small class="allcaps">ADO</small>, you need to call
   your procedure with the command type <b>adCmdStoredProc</b> and use <b>.CreateParameter</b> to specify the parameters. By specifying <b>adCmdStoredProc</b>, you call the stored procedure through <small class="allcaps">RPC</small>, <i>
   Remote Procedure Call</i>, which not only protects you against <small class="allcaps">SQL</small>
   injection, but it is also more efficient. Similar measures apply to other client APIs;
   all APIs I know of supply a way to call a stored procedure through <small class="allcaps">RPC</small>.</p>
<h2><a name="storedprocedures">Dynamic SQL and Stored Procedures</a></h2>
<p>In the <a href="http://www.sommarskog.se/dynamic_sql.html#forks">introduction</a>, I presented various strategies for
   data-access for an application, and I said that in many shops all data access
   is through stored procedures. In this section, I will look a little closer at
   the advantages with using stored procedures over sending <small class="allcaps">SQL</small> statements from
   the client. I will also look at what happens when you use dynamic <small class="allcaps">SQL</small> in a
   stored procedure, and show that you lose some of the advantages with stored
   procedures, whereas other are unaffected.</p>
<h3><a name="permissions">The Permission System</a></h3>
<p>Historically, using stored procedures has been <b>the</b> way to give users
   access to data. In a locked-down database, users do not have permissions to
   access tables directly. Instead, the application performs all
   access through stored procedures that retrieve and update data in a
   controlled way, so that users only get to see data they have access to, and
   they cannot perform updates that violate business rules. This works as long as the
   procedure and the tables have the same owner, typically <b>dbo</b> (the
   database owner), through a mechanism known as <i>ownership chaining</i>.</p>
<p>As I have already mentioned, <i><b>ownership chaining does not work when you
   use dynamic <small class="allcaps">SQL</small></b></i>. The reason for this is very simple: the block of
   dynamic <small class="allcaps">SQL</small> is not a procedure and does not have any owner.
   Thus the chain
   is broken.</p>
<h4>SQL 2005 and later</h4>
<p>In <small class="allcaps">SQL</small>&nbsp;2005 and later versions of <small class="allcaps">SQL</small> Server, this can be addressed by signing a procedure that uses dynamic
   <small class="allcaps">SQL</small> with a certificate. You associate the certificate with a user, and grant
   that user (which is a user that cannot log in) the rights needed for the
   dynamic <small class="allcaps">SQL</small> to execute successfully. A second method is to use
   the <small class="allcaps">EXECUTE AS</small> clause to impersonate a user that has been granted the
   necessary permissions. This method is easier to use, but has side effects
   that can have unacceptable consequences for auditing, row-level security
   schemes and system monitoring. For this reason, my strong recommendation is
   to use certificates.</p>
<p>Describing these methods more closely, would take up too much space here.
   Instead I've written a separate article about them, <a href="http://www.sommarskog.se/grantperm.html"><i>Giving Permissions through Stored
   Procedures</i></a>, where I discusses both certificates and impersonation in
   detail, and I also take a closer look on ownership chaining. </p>
<p>If you write <small class="allcaps">CLR</small> procedures that perform data access, the same is true
   for them.
   Ownership chaining never applies since all data access in a <small class="allcaps">CLR</small> procedure is
   through dynamic <small class="allcaps">SQL.</small> But you can use certificates or
   impersonation to avoid having to give users direct permissions on the
   tables.</p>
<h4>SQL 2000 and earlier</h4>
<p>On <small class="allcaps">SQL</small>&nbsp;2000 there is <i><b>no way</b></i>
   to combine dynamic <small class="allcaps">SQL</small> with the encapsulation of permissions that you can get
   through stored procedures. Any use of dynamic
   <small class="allcaps">SQL</small> requires that the users have direct permissions on the accessed tables. If your security
   scheme precludes giving users permissions to access tables directly, <i><b>you cannot
   use dynamic <small class="allcaps">SQL</small></b></i>. It is that plain and simple. Depending on the
   sensitivity of the data in the application, it may be acceptable to give the
   users <small class="allcaps">SELECT</small> permissions on the tables (or on some tables) to permit the use
   of dynamic <small class="allcaps">SQL</small>. I strongly recommend against granting users <small class="allcaps">INSERT, UPDATE</small>
   and <small class="allcaps">DELETE</small> rights on tables only to permit dynamic <small class="allcaps">SQL
   in some occasional procedure.</small></p>
<p>There are however, some ways to arrange so that users only have access to the data through the application. All and
all, there are three alternatives, application roles, "application
   proxies" and Terminal Server. All require you to change the application architecture or infrastructure, so it
   is nothing you introduce at whim.</p>
<p>Application roles were introduced in <small class="allcaps">SQL</small>&nbsp;7. Users log into <small class="allcaps">SQL</small> Server but have no permissions on their own beyond
   the database access. Instead, the application activates the application role by
   sending a password somehow embedded into it, and this application
   role has the permissions needed. With "application proxies", the application authenticates the users outside <small class="allcaps">SQL</small> Server and logs into <small class="allcaps">SQL</small>
   Server on their behalf with a proxy login. This proxy login impersonates the users in <small class="allcaps">SQL</small> Server, and
   thus their permissions apply. However, since the users do not have any login on their own, they cannot
   log into <small class="allcaps">SQL</small> Server outside the application. In <i><a href="http://www.sommarskog.se/grantperm.html">Giving Permissions...</a></i>,
   I discuss these two methods a little further. </p>
<p>The final possibility is to put the application on Terminal Server. Users log into the terminal server which is set
up so that all they can do is to run this application. Furthermore, the network is configured so that they cannot access <small class="allcaps">SQL</small> Server from their regular
computers. Thus, the application is their only way to the data. </p>
<p>For all these methods, keep in mind about <small class="allcaps">SQL</small> injection, and do not grant more
permissions than needed.</p>
<h3><a name="queryplans">Caching Query Plans</a></h3>
<p>Every query you run in <small class="allcaps">SQL</small> Server requires a query plan. When you run a query
   the first time, <small class="allcaps">SQL</small> Server builds a query plan for it – or as the terminology
   goes – it <i>compiles</i> the query. <small class="allcaps">SQL</small> Server saves the plan in cache, and next time you run
   the query, the plan is reused. The query plan stays in cache
   until it's aged out because it has not been used for a while, or it is
   invalidated for some reason. (Why this happens falls outside the scope of
   this article.)</p>
<p>The reuse of cached query plans is very important for the performance
   of queries where the compilation time is in par with the execution time or
   exceeds it. If
   a query needs to run for four minutes, it does not matter much if the query
   is recompiled for an extra second each time. On the other hand, if the execution time of the
   query is 40&nbsp;ms but it takes one second to compile the query, there is a
   huge gain with the cached plan, particularly if the query is executed over and
   over again.</p>
<p>Up to <small class="allcaps">SQL</small>&nbsp;6.5 the only plans there were put
   into the cache were plans for stored
   procedures. Loose batches of <small class="allcaps">SQL</small> were compiled each time. And since the
   query plan for dynamic <small class="allcaps">SQL</small> is not part of the stored procedure, that included
   dynamic <small class="allcaps">SQL</small> as well. Thus in <small class="allcaps">SQL</small>&nbsp;6.5, the use of dynamic <small class="allcaps">SQL</small> nullified the
   benefit with stored procedures in this regard.</p>
<p>Starting with <small class="allcaps">SQL</small>&nbsp;7, <small class="allcaps">SQL</small> Server also caches the plans for bare statements
   sent from a client or generated through dynamic <small class="allcaps">SQL</small>. Say that you send this
   query from the client, or execute it with <small class="allcaps"><nobr>EXEC()</nobr></small>:</p>
<pre>SELECT O.OrderID, SUM(OD.UnitPrice * OD.Quantity)
FROM   Orders O
JOIN   [Order Details] OD ON O.OrderID = OD.OrderID
WHERE  O.OrderDate BETWEEN '19980201' AND '19980228'
  AND  EXISTS (SELECT *
               FROM   [Order Details] OD2
               WHERE  O.OrderID = OD2.OrderID
                  AND OD2.ProductID = 76)
GROUP  BY O.OrderID</pre>
<p>The query returns the total order amount for the orders in February 1998 that
   contained the product <i>Lakkalikööri.</i> <small class="allcaps">SQL</small> Server will put
   the plan into the cache,
   and next time you run this query, the plan will be reused. But only if it is exactly the same query.
   Since the cache lookup is by a hash value computed from the query text, the cache is space- and case-sensitive.
   Thus, if you add a
   single space somewhere, the plan is not reused. More importantly, it is not
   unlikely that next time you want to run the query for a different product, or a
   different period.</p>
<p>All this changes, if you instead use <b>sp_executesql</b> to run your query
   with parameters:</p>
<pre>DECLARE @sql nvarchar(2000)
SELECT @sql = 'SELECT O.OrderID, SUM(OD.UnitPrice * OD.Quantity)
               FROM   <b>dbo</b>.Orders O
               JOIN   <b>dbo</b>.[Order Details] OD ON O.OrderID = OD.OrderID
               WHERE  O.OrderDate BETWEEN @from AND @to
                 AND  EXISTS (SELECT *
                              FROM   <b>dbo</b>.[Order Details] OD2
                              WHERE  O.OrderID = OD2.OrderID
                                AND  OD2.ProductID = @prodid)
                GROUP  BY O.OrderID'
EXEC sp_executesql @sql, N'@from datetime, @to datetime, @prodid int',
                   '19980201', '19980228', 76</pre>
<p>The principle for cache lookup is the same as for a non-parameterised query:
   <small class="allcaps">SQL</small> Server hashes the query text and looks up the hash value in the cache,
   still in a case- and space-sensitive fashion. But since the parameter values
   are
   not part of the query text, the same plan can be reused even when the input
   changes.</p>
<p>To make this really efficient there is one more thing you need to observe.
   Do you see that I've prefixed all tables in the query with <b>dbo</b>? There
   is a very important reason for this. Users can have different default schema, and up to <small class="allcaps">SQL</small>&nbsp;2000, all users had a
default schema equal to their username. Thus, if default schema for <b>user1</b> is <b>user1</b>, and this users runs a query that goes "<small class="allcaps">SELECT ... FROM</small>
   Orders", <small class="allcaps">SQL</small> Server must first check if there is a table <b>user1.Orders</b>,
   before it looks for <b>dbo.Orders</b>. Since <b>user1.Orders</b> could appear
   on the scene at any time, <b>user1</b> cannot share cache entry with a user different default schema. Yes, in <small class="allcaps">SQL</small>&nbsp;2005, it is perfectly possible that all users have <b>dbo</b> as their default schema, but it seems to be a bad idea to
rely on it.</p>
<p>If you instead use stored procedures, it is not equally important to prefix
   tables with <b>dbo</b>. Microsoft still recommends that you do, but even if
   you don't, users with different default schema can share the same query
   plan.</p>
<p>From what I have said here, it follows that if you use dynamic <small class="allcaps">SQL</small> with
   <small class="allcaps"><nobr>EXEC()</nobr></small> you lose an important benefit of stored procedures
   whereas with <b>sp_executesql</b> you don't. At least in
   theory. It's easy to forget that <b>dbo</b>, and if you leave it out in just a
   single place in the query, you will get as
   many entries in the cache for the query as there are users running it. Recall
   also that the cache is space-
   and case-sensitive, so if you generate the same query in several places, you
   may inadvertently have different spacing or inconsistent use of case.
   And this is not restricted to the <small class="allcaps">SQL</small> statement, the parameter list is as much part of the cache entry. Furthermore, since the cache lookup is by a hash value computed from the query text, I
   would assume that this is somewhat more expensive than looking up a stored
   procedure. In fact, under extreme circumstances, heavy use of dynamic <small class="allcaps">SQL</small>, can lead to serious
   performance degradation. Some of my <small class="allcaps">MVP</small> colleagues have observed systems with
   lots of memory (&gt;&nbsp;20&nbsp;GB) when the plan cache has been so filled with plans
   for <small class="allcaps">SQL</small> statements, that there have been hash collisions galore, and the
   cache lookup alone could take several seconds. Presumably, the applications in
   question either did not use parameterised queries at all, or they failed to
   prefix tables with <b>dbo</b>.</p>
<p>So far, I've only talked about dynamic <small class="allcaps">SQL</small> in stored procedures. But in this
   regard there is very little difference to <small class="allcaps">SQL</small> statements sent from
   the client, or <small class="allcaps">SQL</small> statements generated in <small class="allcaps">CLR</small> procedures. The same rules
   apply: unparameterised statements are cached but with little probability for
   reuse, whereas parameterised queries can be as efficient as stored
   procedures if you remember to always prefix the tables with <b>dbo</b>. (And still
   with the caveat that the cache lookup is space- and case-sensitive.) Most client APIs implement
   parameterised queries by calling <b>sp_executesql</b> under the covers.</p>
<p>In the section on <a href="http://www.sommarskog.se/dynamic_sql.html#SQL_injection"> <small class="allcaps">SQL</small> Injection</a>, I included an example on how to do
   parameterised queries with <small class="allcaps">ADO</small> and VB6.
   Here is an example with VB .Net and SqlClient:</p>
<pre>cmd.CommandType = System.Data.CommandType.Text
cmd.CommandText = _
    " SELECT O.OrderID, SUM(OD.UnitPrice * OD.Quantity)" &amp; _
    " FROM   dbo.Orders O " &amp; _
    " JOIN   dbo.[Order Details] OD ON O.OrderID = OD.OrderID" &amp; _
    " WHERE  O.OrderDate BETWEEN @from AND @to" &amp; _
    "   AND  EXISTS (SELECT *" &amp; _
    "                FROM   dbo.[Order Details] OD2" &amp; _
    "                WHERE  O.OrderID = OD2.OrderID" &amp; _
    "                  AND  OD2.ProductID = @prodid)" &amp; _
    " GROUP  BY O.OrderID"

cmd.Parameters.Add("@from", SqlDbType.Datetime)
cmd.Parameters("@from").Value = "1998-02-01"

cmd.Parameters.Add("@to", SqlDbType.Datetime)
cmd.Parameters("@to").Value = "1998-02-28"

cmd.Parameters.Add("@prodid", SqlDbType.Int)
cmd.Parameters("@prodid").Value = 76</pre>
<p>In contrast to <small class="allcaps">ADO</small>, SqlClient uses names with @ for parameters. The syntax
   for defining parameters is similar to <small class="allcaps">ADO</small>, but not identical. This article is
   long enough, so I will not go into details on how the <b>Parameters</b>
   collection works. Instead, I refer you to <small class="allcaps">MSDN</small> where both SqlClient and <small class="allcaps">ADO</small>
   are documented in detail. Whatever client <small class="allcaps">API</small> you are using,
   <i><b>please</b></i>
   learn how to use parameterised commands with it. Yes, there is a tone of
   desperation in my voice. I don't know how many posts I've seen on the
   newsgroups over the years where people build their <small class="allcaps">SQL</small> strings by
   interpolating the values from input fields into the <small class="allcaps">SQL</small> string, and thereby
   degrading the performance of their application, and worst of all opening
   their database to <small class="allcaps">SQL</small> injection.</p>
<p>... and just when you thought you were safe, I need to turn this upside down. Recall what I said in the beginning of
this section, that if the query is going to run for four minutes, one second extra for compilation is not a big deal.
And if that recompilation slashes the execution time from forty minutes to four, there is a huge gain. Most queries
benefit from cached parameterised plans, but not all do. Say that you have a query where the user can ask for data for
some time span. If the user asks for a summary for a single day, there is a good non-clustered index that can be used
for a sub-second response time. But if the request is for the entire year, the same index would be a disaster, and a
table scan is better. Starting with <small class="allcaps">SQL</small>&nbsp;2005 you can force a
   query to be recompiled each
   time it is executed by adding <small class="allcaps">OPTION (RECOMPILE)</small>
   to the end of the query, and thus you can still use <b>sp_executesql</b> to get the
   best protection against <small class="allcaps">SQL</small> injection. On <small class="allcaps">SQL</small>&nbsp;2000
   and earlier, it may in fact be better to interpolate critical parameters into the
   query string when you need to force recompilation each time. </p>
<p>For the sake of completeness, I should mention that <small class="allcaps">SQL</small>
   Server is able to auto-parameterise queries. If you submit:</p>
<pre>SELECT OrderID, OrderDate FROM dbo.Orders WHERE CustomerID = N'ALFKI'</pre>
<p><small class="allcaps">SQL</small> Server may recast this as </p>
<pre>SELECT OrderID, OrderDate FROM dbo.Orders WHERE CustomerID = @P1</pre>
<p>so if next time you submit <small class="allcaps">BERGS</small> instead of <small class="allcaps">ALFKI</small>, the query plan will be reused.
   Auto-parameterisation comes in two flavours: simple and forced. Simple is the
   default and is the only option on <small class="allcaps">SQL</small>&nbsp;2000 and
   earlier. With simple parameterisation, auto-parameterisation happens only with very simple
   queries, and, it seems, with some inconsistency. With forced
   parameterisation, <small class="allcaps">SQL</small> Server parameterises all queries that comes its way
   (with some exceptions documented in Books Online). Forced parameterisation
   is, in my opinion, mainly a setting to cover up for poorly designed
   third-party application that uses unparameterised dynamic
   <small class="allcaps">SQL</small>. For your own development you should not
   rely on any form of auto-parameterisation. (But in the situation you really a want a new query
   plan each time, you may have to verify that it doesn't happen when you don't
   want to.)</p>
<p>They say seeing is believing. Here is a demo that you can try on yourself, if
   you have <small class="allcaps">SQL</small>&nbsp;2005. First create this database:</p>
<pre>CREATE DATABASE many_sps
go
USE many_sps
go
DECLARE @sql nvarchar(4000),
        @x   int
SELECT @x = 200
WHILE @x &gt; 0
BEGIN
   SELECT @sql = 'CREATE PROCEDURE abc_' + ltrim(str(@x)) +
                 '_sp @orderid int AS
   SELECT O.OrderID, O.OrderDate, O.CustomerID, C.CompanyName,
          Prodcnt = OD.cnt, Totalsum = OD.total
   FROM   Northwind..Orders O
   JOIN   Northwind..Customers C ON O.CustomerID = C.CustomerID
   JOIN   (SELECT OrderID, cnt = COUNT(*), total = SUM(Quantity * UnitPrice)
           FROM   Northwind..[Order Details]
           GROUP  BY OrderID) AS OD ON OD.OrderID = O.OrderID
   WHERE  O.OrderID = @orderid'
   EXEC(@sql)
   SELECT @x = @x - 1
END </pre>
<p>Then in <small class="allcaps">SQL</small> Server Management Studio 2005, press F7
   navigate down to the list of stored procedures. Select all procedures. Then
   from the context menu select to script them as <small class="allcaps">CREATE
   TO</small> to a new query window. How long time this takes depends on your
   hardware, but on my machine it took 90 seconds and at the same time <small class="allcaps">SQL</small>
   Server grabbed over 250&nbsp;<small class="allcaps">MB</small> of memory. If you
   use the Profiler to see what Mgmt Studio is up to, you will see that for each
   procedure, Mgmt Studio emits a couple of queries with the procedure name
   embedded. That is, no parameterised statements. Once scripting is complete,
   issue this command:</p>
<pre>ALTER DATABASE many_sps SET PARAMETERIZATION FORCED</pre>
<p>and redo the operation. On my machine scripting now completed in five
   seconds!. This demonstrates that the difference between parameterised and
   unparameterised can be dramatic. (And that Microsoft can not use their own
   products properly.) If you run <small class="allcaps">SQL</small> Server on
   your local machine, you can see this from one more angle, you can stop and restart
   <small class="allcaps">SQL</small> Server before the two scripting operations, and then use Task Manager to
   see how much physical memory <small class="allcaps">SQL</small> Server uses
   in the two cases. That difference lies entirely in the plan cache.</p>
<p>This particular issue have been addressed in <small class="allcaps">SQL</small> Server Management Studio 2008. <small class="allcaps">SSMS</small> 2008 has its own scripting
issues, but they have nothing to do with the topic of this article.</p>
<h3><a name="networktraffic">Reducing Network Traffic</a></h3>

<p>Another advantage with stored procedures over <small class="allcaps">SQL</small> sent from the client is that less bytes travel the network. Rather than sending a
   50-line query over the network, you only need to pass the name of a stored procedure
   and a few parameters. This gets more significant if the computation requires
   several queries, possibly with logic in between. If all logic is outside the
   database, this could mean that data has to travel up to the client, only to travel back in the next moment. With stored procedures you can
   use temp tables to hold intermediate results. (You can use temp tables
   from outer layers as well, although it may require some careful use of your
   client <small class="allcaps">API</small>.)</p>
<p>In this case, the dividing line goes between sending <small class="allcaps">SQL</small> from the client or
   running stored procedures. If the stored procedures use static <small class="allcaps">SQL</small> only, or
   invoke dynamic <small class="allcaps">SQL</small> does not matter, nor does it matter if it is a <small class="allcaps">CLR</small> procedure.
   You still get the gains of reduced network traffic.</p>
<h3><a name="encapsulation">Encapsulating Logic</a></h3>

<p>This is not a question of security or performance, but one of
   good programming practice and modularising your code. By using stored procedures, you don't have to bog down
your client code with the construction of <small class="allcaps">SQL</small> statements. Then again, it depends
   a little on what you put into those stored procedure. Myself, I am of the
   school that the business logic should be where the data is, and in this case
   there is no dispute that you should use stored procedures to encapsulate your
   logic.</p>
<p>But there are also people
   who like to see the database as a unintelligent container of data, and who
   prefer to have the business logic
   elsewhere. In this case, the arguments for using stored procedures
   for encapsulation may not be equally compelling. You could just as well employ careful programming practices in
   your client language and send <small class="allcaps">SQL</small> strings.</p>
<p>Nothing of this changes if you use dynamic <small class="allcaps">SQL</small> in your stored procedures. The
   stored procedure is still a container for some piece of logic, and how it
   looks on the inside does not matter. I'm here assuming that most of your
   procedures use static <small class="allcaps">SQL</small> only. If all your stored procedures
   generate dynamic <small class="allcaps">SQL</small>, then you are probably better off in this regard to do it all in client code. Then again, sometimes there is no other application
   than Query Analyzer or <small class="allcaps">SQL</small> Server Management Studio. (Typically this would be
   tasks that are run by an admin.) In this case, the only container of logic
   available is stored procedures, and it's immaterial whether they use dynamic
   <small class="allcaps">SQL</small> or not.</p>
<h3><a name="trackability">Keeping Track of what Is Used</a></h3>

<p>In a complex system with hundreds of tables, you may need to know where a
   certain table or column is referenced, because you are considering changing
   or dropping it. If all access to tables is from static <small class="allcaps">SQL</small> in stored
   procedures, you may be able find all references by using the system
   stored procedure <b>sp_depends</b> or query a system table directly. (<b>sysdepends</b>
   in <small class="allcaps">SQL</small>&nbsp;2000, <b>sys.sql_dependencies</b> in <small class="allcaps">SQL</small>&nbsp;2005
and later. In <small class="allcaps">SQL</small>&nbsp;2008 there is also <strong>sys.sql_expression_dependencies</strong>.) I say may, because it is very difficult to maintain complete dependency
   information in <small class="allcaps">SQL</small> Server. If you drop and recreate a table, all dependency
   information for the table is lost. What I do myself is to regularly build an empty database
   from our version-control system, and since our build tool
   loads all tables before any stored procedure or trigger, I know that I can
   trust the dependency information in that database.</p>
<p>If you throw dynamic <small class="allcaps">SQL</small> into the mix – be that <small class="allcaps">SQL</small> sent from client,
   dynamic <small class="allcaps">SQL</small> in <small class="allcaps"><nobr>T-SQL</nobr></small> procedures, or <small class="allcaps">SQL</small> generated by <small class="allcaps">CLR</small> stored procedures
   - you lose this opportunity. The alternative is to employ brute-force search,
   and if the construction of dynamic <small class="allcaps">SQL</small> is confined to some well-defined set
   of modules, this may work. If not, you may end up with a database where no
   one ever dares to drop or change a column or a table, and which eventually
   becomes unbearable complex and inefficient because of all the legacy baggage
   it's carrying around.</p>
<p>While the main dividing line here is between static <small class="allcaps">SQL</small> and any form of
   dynamic <small class="allcaps">SQL</small>, dynamic <small class="allcaps">SQL</small> in <small class="allcaps"><nobr>T-SQL</nobr></small>
stored procedures is probably the least harmful, as there is less code to search. You can even search
   the column <b>sys.sql_modules.definition</b> using <small class="allcaps">SQL</small>. Available since <small class="allcaps">SQL</small>&nbsp;2005. In <small class="allcaps">SQL</small>&nbsp;2000 you
   can search <b>syscomments</b>, but as the procedure text there is chopped into 4000-char slices, this is less
reliable.</p>
<p>In any case, an occasional stored procedure that uses dynamic <small class="allcaps">SQL</small> is not
   likely cause the Armageddon I pictured above. But it is
   a good argument for being restrictive with dynamic <small class="allcaps">SQL</small> in any form.</p>
<h3><a name="easiness">Ease of Writing SQL Code</a></h3>
<p>One distinct advantage of writing stored <small class="allcaps"><nobr>T-SQL</nobr></small> procedures is that you get a
   syntax check directly. With dynamic <small class="allcaps">SQL</small>, a trivial syntax error may not show up
   until run time. Even if you test your code carefully, there may be some query, or
   some variation of a query, that is only run in odd cases and not covered in
   your test suite. </p>
<p>It has to be admitted that the strength of this argument is somewhat reduced by the fact
   that <small class="allcaps"><nobr>T-SQL</nobr></small> is not too industrious on reporting semantic errors.
   Because of deferred name resolution, <small class="allcaps">SQL</small> Server will not examine queries in
   stored procedures, where one or more tables are missing, be that misspellings
   or temp tables created within the procedure. Nevertheless, <small class="allcaps">SQL</small> Server
   does report sufficiently many errors, for this to be a very important reason
   to use stored procedures.</p>
<p>Another side of this coin is that when you write dynamic <small class="allcaps">SQL</small>, you embed the
   <small class="allcaps">SQL</small> code into strings, which makes programming far more complex. Your <small class="allcaps">SQL</small>
   code is a string delimited by single quotes(<code>'</code>), and this string
   may include strings itself, and to include a single quote into the string you
   need to double it. You can easily get lost in a maze of quotes if you don't
   watch out. (In the section <i><a href="http://www.sommarskog.se/dynamic_sql.html#good_practices">Good Coding Practices
   and Tips for Dynamic <small class="allcaps">SQL</small></a></i>, we will look a little closer
   on how to deal
   with this problem.) The most commonly used client languages with <small class="allcaps"><nobr>T-SQL</nobr></small> -
   Visual Basic, <small class="allcaps">C#, C</small>++, VBScript – all use the double quote (<code>"</code>)
   as their string delimiter, so dynamic <small class="allcaps">SQL</small> in client code or <small class="allcaps">CLR</small> stored
   procedures is less prone to that particular problem. Then again, in VB you
   don't have multi-line strings, so at the end of each line you have to have a double
   quote, an ampersand and an underscore for continuation. It sure does not
   serve to make coding easier. You are relieved from all this hassle, if you
   use stored procedures with static <small class="allcaps">SQL</small> only.</p>
<h3><a name="supportability">Addressing Bugs and Problems</a></h3>
<p>Somewhat surprisingly, one of the strongest arguments for stored procedures today may
   be
 that they permit you to quickly address bugs and performance problems in the
 application.</p>
<p>Say that you generate <small class="allcaps">SQL</small> statements in your application, and that there is
 an error in it. Or that it simply performs unbearably slow. To fix it, you need to
 build a new executable or <small class="allcaps">DLL</small>, which is likely to contain other code that also
   has changed since the module was shipped. This
 means that before the fix can be put into production, the module will have to go
 through QA and testing.</p>
<p>On the other hand, if the problem is in a stored procedure, and the fix is
 trivial, you may be able to deploy a fix into production within an hour after
 the problem was reported. </p>
<p>This difference is even more emphasised, if you are an <small class="allcaps">ISV</small> and you ship a
   product that the customer is supposed administer himself. If your application
   uses stored procedures, a <small class="allcaps">DBA</small> may be able to address problems directly
   without opening a support case. For instance, if a procedure runs unacceptably
   slow, he may be able to fix that by adding an index hint. In contrast,
   with an application that generates <small class="allcaps">SQL</small> in the
 client, his hands will be tied. Of course, as an <small class="allcaps">ISV</small> you may not want your
 customers to poke around in your code, even less to change it. You may also prefer
   to ship your procedures <small class="allcaps">WITH ENCRYPTION</small> to protect
   your intellectual property, but this is best controlled
 through license agreements. (If you encrypt your procedures, the <small class="allcaps">DBA</small> can still
   change them, as long as he is able to find a way to decrypt them. Which any
   <small class="allcaps">DBA</small> that knows how to use Google can do.) </p>
<p>In this case, it does not matter whether the stored procedure uses static <small class="allcaps">SQL</small>
   only, or if it also uses dynamic <small class="allcaps">SQL</small>. For <small class="allcaps">CLR</small> procedures it depends on many objects
   you have in your assemblies. If you have one assembly per object, installing a new version of a <small class="allcaps">CLR</small> procedure
   is as simple as replacing a <small class="allcaps"><nobr>T-SQL</nobr></small> procedure.</p>
<p>(I should add that <small class="allcaps">SQL</small>&nbsp;2005 offers a new feature that permits the <small class="allcaps">DBA</small> to
   change the plan for a query without altering the code, by adding a <i>plan guide</i>.
   This feature has been further enhanced in <small class="allcaps">SQL</small>&nbsp;2008. This is quite an advanced feature, and I refer to Books Online for details.)</p>
<h2><a name="good_practices">Good Coding Practices and Tips for Dynamic SQL</a></h2>
<p>Writing
 dynamic <small class="allcaps">SQL</small> is a task that requires discipline to
avoid losing control
   over your code. If you
   just go ahead, your code can become very messy, and be difficult to read, troubleshoot
   and maintain. In this section, we will look at how to avoid this. I will also
   discuss some special cases: how you can use <b>sp_executesql</b> for input longer
   than 4000 chars in <small class="allcaps">SQL</small>&nbsp;2000, and how to use dynamic <small class="allcaps">SQL</small> with cursors, and the
   combination of dynamic <small class="allcaps">SQL</small> and user-defined functions.</p>
<h3><a name="debugprints">Use Debug Prints!</a></h3>
<p>When you write a stored procedure that generates dynamic <small class="allcaps">SQL</small>, you should
   always include a @debug parameter:</p>
<pre>CREATE PROCEDURE dynsql_sp @par1 int,
                           ...
                           @debug bit = 0 AS
...
IF @debug = 1 PRINT @sql</pre>
<p>When you get a syntax error from the dynamic <small class="allcaps">SQL</small>, it can be very confusing, and
   you may not even discern where it comes from. And even when you do, it can be
   very difficult to spot the error only by looking at the code that constructs the <small class="allcaps">SQL</small>.
   Once the <small class="allcaps">SQL</small> code is slapped in your face, the error is much more likely to be apparent to you.
   So always include a @debug parameter and a <small class="allcaps">PRINT</small>!</p>
<h3><a name="nestedstrings">Nested Strings</a></h3>
<p>As I've already mentioned, one problem with dynamic <small class="allcaps">SQL</small> is that you often need to deal with nested
   string delimiters. For instance, in the beginning of this article, I showed
   you the procedure <b>general_select2</b>. Here it is again:</p>
<pre>CREATE PROCEDURE general_select2 @tblname nvarchar(127),
                                 @key     varchar(10) AS
EXEC('SELECT col1, col2, col3
      FROM ' + @tblname + '
      WHERE keycol = ''' + @key + '''')</pre>
<p>(Again, I like to emphasise that this sort of procedure is poor use of
   dynamic <small class="allcaps">SQL</small>.)</p>
<p>
<small class="allcaps">SQL</small> is one of those language where the method to include a string
delimiter itself in a string literal is to double it. So those four consecutive
single quotes <code>('''')</code> is a string literal with the value of a one
single quote (<code>'</code>).
This is a fairly simple example; it can get a lot worse. If you work with
dynamic <small class="allcaps">SQL</small>, you must learn to master nested strings. Obviously, in this case you
can easily escape the mess by using <b>sp_executesql</b> instead – yet another reason
to use parameterised statements. However, there are situations when you need to
deal with nested quotes even with <b>sp_executesql</b>. For instance, earlier in this
article, I had this code:</p>
<pre>N' WHERE LastUpdated BETWEEN @fromdate AND '
N'                           coalesce(@todate, ''99991231'')'</pre>
<p>We will look at some tips of dealing with nested strings later in this
   section.</p>
<h3><a name="formatting">Spacing and Formatting</a></h3>
<p>Another thing to be careful with is the spacing as you concatenate the parts
   of a query.
   Here is an example where it goes wrong:</p>
<pre>EXEC('SELECT col1, col2, col3
      FROM' + @tblname + '
      WHERE keycol = ''' + @key + '''')</pre>
<p>
See that there is a space missing after <small class="allcaps">FROM</small>? When you compile the stored procedure
you will get no error, but when you run it, you will be told that the columns <i>
keycol</i>, <i>col1, col2, col3</i> are missing. And since you know that the
table you passed to the procedure has these columns you will be mighty confused. But this is
the actual code generated, assuming the parameters <b>foo</b> and <b>abc</b>:</p>
<pre>SELECT col1, col2, col3
    FROMfoo
    WHERE keycol = 'abc'</pre>
This is not a syntax error, because <code>FROMfoo</code> is a column alias to <i>col3</i>.
And, yes, it's legal to use a <small class="allcaps">WHERE</small> clause, even if there is no <small class="allcaps">FROM</small> clause. But
since the columns cannot exist out of the blue, you get an error for that.<p>
   This is also a good example why you should use debug prints. If the code
   looks like this:</p>
<pre>SELECT @sql =' SELECT col1, col2, col3
               FROM' + @tblname + '
               WHERE keycol = ''' + @key + ''''
IF @debug = 1 PRINT @sql
EXEC(@sql)</pre>
<p>It would be much easier to find the error by running the procedure with
   @debug = 1. (Obviously, had we included the <b>dbo</b> prefix, this error
   could not occur at all.)</p>
<p>Overall, good formatting is essential when working with dynamic <small class="allcaps">SQL</small>. Try to
   write the query as you would have written it in static <small class="allcaps">SQL</small>, and then add the
   string delimiters outside of that. <small class="allcaps"><nobr>T-SQL</nobr></small> permits you to embed newlines in
   string literals (as testified by the example above), so in contrast to VB,
   you don't need a string delimiter on each line. An advantage of this is that
   your debug <small class="allcaps">PRINT</small> is easier to read, and in the case of a syntax error the line
   number in the error message may guide you.</p>
<p>You may prefer, though, to
   have a string terminator on each line. A tip in such case is to do something
   like this:</p>
<pre>EXEC(' SELECT col1, col2, col3 ' +
     ' FROM ' + @tblname +
     ' WHERE keycol = ''' + @key + '''')</pre>
<p>As you see, I have a space after the opening single quote on each line to avoid syntax problems due to missing spaces.</p>
<h3><a name="objectnames">Dealing with Dynamic Table and Column Names</a></h3>
<p>Passing table and column names as parameters to a procedure with dynamic <small class="allcaps">SQL</small>
   is rarely a good idea for application code. (It can make perfectly sense for
   admin tasks). As I've said, you cannot pass a table or a column name as a
   parameter to <b>sp_executesql</b>, but you must interpolate it into the <small class="allcaps">SQL</small> string.
   Still you should protect it against <small class="allcaps">SQL</small>
   injection, as a matter of routine. It could be that bad it comes from user
   input. </p>
<p>To this end, you should use the built-in function <b><nobr>quotename()</nobr></b> (added in
   <small class="allcaps">SQL</small>&nbsp;7). <nobr><b>quotename()</b></nobr> takes two parameters: the first is a string, and the second
   is a pair of delimiters to wrap the string in. The default for the second
   parameter is []. Thus, <code><nobr>quotename('Orders')</nobr></code> returns <code>
   [Orders]</code>. <nobr><b>quotename()</b></nobr> takes care of nested delimiters, so if you have
   a really crazy table name like <b>Left]Bracket</b>, <nobr><b>quotename()</b></nobr> will
   return <code><nobr>[Left]]Bracket]</nobr></code>.</p>
<p>Note that when you work with names with several components, each component
   should be quoted separately. <code><nobr>quotename('dbo.Orders')</nobr></code> returns
   <code><nobr>[dbo.Orders]</nobr></code>, but that is a table in an unknown
   schema of which the first four characters are <b>d</b>, <b>b</b>, <b>o</b> and
   a dot. As long as you only work with the <b>dbo</b> schema, best practice is to
   add <b>dbo</b> in the dynamic <small class="allcaps">SQL</small> and only pass the table name. If you work
   with different schemas, pass the schema as a separate parameter. (Although
   you could use the built-in function <nobr><b>parsename()</b></nobr> to split up a
   @tblname
   parameter in parts.)</p>
<p>While <b>general_select</b> still is a poor idea as a stored procedure, here
   is nevertheless a version that summarises some good coding
   virtues for dynamic <small class="allcaps">SQL</small>:</p>
<pre>CREATE PROCEDURE general_select @tblname nvarchar(128),
                                @key     varchar(10),
                                @debug   bit = 0 AS
DECLARE @sql nvarchar(4000)
SET @sql = 'SELECT col1, col2, col3
            FROM dbo.' + quotename(@tblname) + '
            WHERE keycol = @key'
IF @debug = 1 PRINT @sql
EXEC sp_executesql @sql, N'@key varchar(10)', @key = @key</pre>
<ul>
   <li>I'm using <b>sp_executesql</b> rather than <small class="allcaps"><nobr>EXEC()</nobr></small>.</li>
   <li>I'm prefixing the table name with <b>dbo</b>.</li>
   <li>I'm wrapping @tblname in <b><nobr>quotename()</nobr></b>.</li>
   <li>There is a @debug parameter.</li>
</ul>
<h3><a name="quotestring">Quotename, Nested Strings and Quotestring</a></h3>
<p>
The main purpose of <nobr><b>quotename()</b></nobr> is to quote object names, which is why the
default for the second parameter is brackets. But you can specify other
delimiters as well, including single quotes, which means that any single quote
in the input is doubled. Thus, if you for some reason prefer to use
     <small class="allcaps"><nobr>EXEC()</nobr></small>, you can use <b><nobr>quotename()</nobr></b> to protect yourself against <small class="allcaps">SQL</small>
     injection by help of this function. Here is an example.</p>
<pre>IF @custname IS NOT NULL
   SELECT @sql = @sql + ' AND custname = ' + quotename(@custname, '''')</pre>
<p>Say that @custname has the value <i>D'Artagnan</i>. This part of the dynamic <small class="allcaps">SQL</small>
   becomes:</p>
<pre>AND custname = 'D''Artagnan'</pre>
<p>There is a limitation with <b><nobr>quotename()</nobr></b>: its input parameter
     is <b>nvarchar(128)</b>, so it does not handle long strings. A remedy is this user-defined function: </p>
<pre>CREATE FUNCTION quotestring(@str nvarchar(1998)) RETURNS nvarchar(4000) AS
BEGIN
   DECLARE @ret nvarchar(4000),
           @sq  char(1)
   SELECT @sq = ''''
   SELECT @ret = replace(@str, @sq, @sq + @sq)
   RETURN(@sq + @ret + @sq)
END</pre>
<p>This version is for <small class="allcaps">SQL</small>&nbsp;2000. On <small class="allcaps">SQL</small>&nbsp;2005 and
later, replace 1998 and 4000 with <small class="allcaps">MAX,
   to make it work for any string length. </small>Here is an example of using this function:</p>
<pre>IF @custname IS NOT NULL
   SELECT @sql = @sql + ' AND custname = ' + dbo.quotestring(@custname)</pre>
<p>
The result is the same as above.</p>
<p>
On <small class="allcaps">SQL</small>&nbsp;7, you would have to implement <b>quotestring</b> as a stored procedure.
<small class="allcaps">SQL</small>&nbsp;6.5 does not have <b><nobr>replace()</nobr></b>, so you are a bit out of luck there. </p>
<p>
So with <nobr><b>quotename()</b></nobr> and <nobr><b>quotestring()</b></nobr>,
do we have as good protection against <small class="allcaps">SQL</small>
injection as we have with parameterised commands? Maybe. I don't know of any way to
inject <small class="allcaps">SQL</small> that slips through <nobr><b>quotename()</b></nobr> or <nobr><b>quotestring()</b></nobr>. Nevertheless, you
are interpolating user input into the <small class="allcaps">SQL</small> string, whereas with parameterised
commands, you don't.</p>
<p>
(I
should add that I got the suggestion to use <b><nobr>quotename()</nobr></b> or a user-defined
function from <small class="allcaps">SQL</small> Server <small class="allcaps">MVP</small> Steve Kass.)</p>
<h3><a name="QUOTED_IDENTIFIER">QUOTED_IDENTIFIER</a></h3>
<p>Another alternative to
   escape the mess of nested quotes, is make use
   of the fact that <small class="allcaps"><nobr>T-SQL</nobr></small> actually has two string delimiters. To wit, if the
   setting <small class="allcaps">QUOTED_IDENTIFIER</small> is <small class="allcaps">OFF</small>, you can also use double quotes(<code>"</code>)
   as a string delimiter. The default
   for this setting depends on context, but the preferred setting is
   <small class="allcaps">ON</small>, and it
   must be <small class="allcaps">ON</small> in order to use XQuery, indexed views and indexes on computed columns.
   Thus, this is not a first-rate alternative, but if you are aware of the caveats,
   you can do this:</p>
<pre>CREATE PROCEDURE general_select @tblname nvarchar(127),
                                @key     key_type,
                                @debug   bit = 0 AS
DECLARE @sql nvarchar(4000)

SET @sql = 'SET QUOTED_IDENTIFIER OFF
            SELECT col1, col2, col3
            FROM dbo.' + quotename(@tblname) + '
            WHERE keycol = "' + @key + '"'
IF @debug = 1 PRINT @sql
EXEC(@sql)</pre>

<p>Since there are two different quote characters, the code is much easier to
   read. The single quotes are for the <small class="allcaps">SQL</small> string and the double quotes
   are for
   the embedded string literals. </p>
<p>All and all, this is an inferior method to both <b>sp_executesql</b> and <b><nobr>quotestring()</nobr></b>, since you are not protected against <small class="allcaps">SQL</small> injection
   (what if @key includes a double quote?). But it
   would be OK to do for some sysadmin task (where <small class="allcaps">SQL</small> injection is not likely
   to be an issue), and it may be the best way to go on <small class="allcaps">SQL</small>&nbsp;6.5. </p>
<h3><a name="sp_executesqlong">sp_executesql and Long SQL Strings in SQL 2000</a></h3>
<p>There is a limitation with <b>sp_executesql</b> on <small class="allcaps">SQL</small>&nbsp;2000
   and <small class="allcaps">SQL</small>&nbsp;7, since you cannot use longer <small class="allcaps">SQL</small>
   strings than 4000 characters. (On <small class="allcaps">SQL</small>&nbsp;2005 and later,
   you should use <b>nvarchar(<small class="allcaps">MAX</small>)</b> to avoid this
   problem.) If you
   want to use <b>sp_executesql</b> when your query string exceeds this limit to make use of parameterised query plans, there is actually a
   workaround. To wit, you can wrap <b>sp_executesql</b> in <small class="allcaps"><nobr>EXEC()</nobr></small>:</p>
<pre>DECLARE @sql1 nvarchar(4000),
        @sql2 nvarchar(4000),
        @state char(2)
SELECT @state = 'CA'
SELECT @sql1 = N'SELECT COUNT(*)'
SELECT @sql2 = N'FROM dbo.authors WHERE state = @state'
EXEC('EXEC sp_executesql N''' + @sql1 + @sql2 + ''',
                         N''@state char(2)'',
                         @state = ''' + @state + '''')</pre>
<p>This works, because the @stmt parameter to <b>sp_executesql</b> is <b>ntext</b>, so by
   itself, it does not have any limitation in size.</p>
<p>You can even use output parameters by using
   <a href="http://www.sommarskog.se/share_data.html#INSERTEXEC"><small class="allcaps">INSERT-EXEC</small></a>, as
   in this example:</p>
<pre>CREATE TABLE #result (cnt int NOT NULL)
DECLARE @sql1  nvarchar(4000),
        @sql2  nvarchar(4000),
        @state char(2),
        @mycnt int
SELECT @state = 'CA'
SELECT @sql1 = N'SELECT @cnt = COUNT(*)'
SELECT @sql2 = N'FROM dbo.authors WHERE state = @state'
INSERT #result (cnt)
   EXEC('DECLARE @cnt int
         EXEC sp_executesql N''' + @sql1 + @sql2 + ''',
                            N''@state char(2),
                               @cnt   int OUTPUT'',
                            @state = ''' + @state + ''',
                            @cnt = @cnt OUTPUT
         SELECT @cnt')
SELECT @mycnt = cnt FROM #result</pre>
<p>You have my understanding if you think this is too messy to be worth it.</p>
<h3><a name="UDF">Dynamic SQL in User-Defined Functions</a></h3>
<p>This very simple: you <i><b>cannot</b></i> use dynamic <small class="allcaps">SQL</small> from used-defined functions
   written in <small class="allcaps"><nobr>T-SQL</nobr></small>. This is because you are not permitted do anything in a <small class="allcaps">UDF</small>
   that could change the database state (as the <small class="allcaps">UDF</small> may be invoked as part of a
 query). Since you can do anything from dynamic <small class="allcaps">SQL</small>, including updates, it is
 obvious why dynamic <small class="allcaps">SQL</small> is not permitted.</p>
<p>I've seen more than one post on the newsgroups where people have
   been banging their head against this. But if you want to use dynamic <small class="allcaps">SQL</small> in a
 <small class="allcaps">UDF</small>, back out
   and redo your design. You have hit a roadblock, and in <small class="allcaps">SQL</small>&nbsp;2000 there is no
   way out.</p>
<p>In <small class="allcaps">SQL</small>&nbsp;2005 and later, you could implement your function as a <small class="allcaps">CLR</small> function. Recall that
   all data access from the <small class="allcaps">CLR</small> is dynamic <small class="allcaps">SQL.</small> (You are safe-guarded, so that if
   you perform an update operation from your function, you will get caught.) A
   word of warning though: data access from scalar UDFs can often give performance
   problems. If you say </p>
<pre>SELECT ... FROM tbl WHERE dbo.MyUdf(somecol) = @value</pre>
<p>and <b>MyUdf</b> performs data access, you have more or less created a hidden
   cursor. </p>
<h3><a name="cursor0">Cursors and Dynamic SQL</a></h3>
<p>Not that cursors are something you should use very frequently, but people often
ask about using dynamic <small class="allcaps">SQL</small> with cursors, so I give an example for the sake
   of completeness. You cannot say <kbd>DECLARE CURSOR <nobr>EXEC()</nobr></kbd>; you have to put the
entire <small class="allcaps">DECLARE CURSOR</small> statement in dynamic <small class="allcaps">SQL</small>:</p>
<pre>SELECT @sql = 'DECLARE my_cur INSENSITIVE CURSOR FOR ' +
              'SELECT col1, col2, col3 FROM ' + @table
EXEC sp_executesql @sql</pre>
<p>You may be used to using the <small class="allcaps">LOCAL</small> keyword with your cursors. However, it is
   important to understand that you must use a global cursor, as a local cursor
   will disappear when the dynamic <small class="allcaps">SQL</small> exits. (Because, as you know by now, the
   dynamic <small class="allcaps">SQL</small> is its own scope.) Once you have declared the
   cursor in this way, you can use the cursor in a normal fashion. You must be
   extra careful with error-handling though, so that you don't exit the
   procedure without deallocating the cursor. </p>
<p>There is however a way to use locally-scoped cursors with dynamic <small class="allcaps">SQL</small>.
   Anthony Faull pointed out to me that you can achieve this with cursor variables, as in this example:</p>
<pre>DECLARE @my_cur CURSOR
EXEC sp_executesql
     N'SET @my_cur = CURSOR STATIC FOR
       SELECT name FROM dbo.sysobjects;
       OPEN @my_cur',
     N'@my_cur cursor OUTPUT', @my_cur OUTPUT
FETCH NEXT FROM @my_cur</pre>
<p>
You refer to a cursor variable, just like named cursors, but there is an @ in front,
and, as you see from the example, you can pass them as a parameters. (I have to confess
I have never seen any use for cursor variables until Anthony Faull was kind to send
me this example.)</p>
<h2><a name="EXECatlinked"><nobr>EXEC()</nobr> at Linked Server</a></h2>
<p>A special feature added in <small class="allcaps">SQL</small>&nbsp;2005 is that you can use <small class="allcaps"><nobr>EXEC()</nobr></small> to run
   pass-through queries on a linked server. This could be another instance of
   <small class="allcaps">SQL</small> Server, but it could also be an Oracle server, an Access database, Active
   directory or whatever. The <small class="allcaps">SQL</small> could be a single query or a sequence of
   statements, and could it be composed dynamically or be entirely static. The syntax
   is simple, as seen by this example:</p>
<pre>EXEC('SELECT COUNT(*) FROM ' + @db + '.dbo.sysobjects') AT SQL2K</pre>
<p><small class="allcaps">SQL2K</small> is here a linked server that has been defined with <b>
   sp_addlinkedserver</b>.</p>
<p>There is one thing that you can do with <small class="allcaps"><nobr>EXEC()</nobr></small> at a linked server, that you
   cannot do with <small class="allcaps"><nobr>EXEC()</nobr></small> on a local server: you can use parameters, both for
   input and output. The confuse matters, you don't use parameters with names
   starting with @, instead you use question marks (<code>?</code>) as parameter
   holders. Say that you are on an <small class="allcaps">SQL</small>&nbsp;2005 box, and you are dying to know how
   many orders <small class="allcaps">VINET</small> had in the <b>Northwind</b> database. Unfortunately, <small class="allcaps">SQL</small>&nbsp;2005 does
   not ship with <b>Northwind</b>, but you have a linked server set up to an instance
   of <small class="allcaps">SQL</small>&nbsp;2000 with <b>Northwind</b>. You can run this:</p>
<pre>DECLARE @cnt int
EXEC('SELECT ? = COUNT(*) FROM Northwind.dbo.Orders WHERE CustomerID = ?',
      @cnt OUTPUT, N'VINET') AT SQL2K
SELECT @cnt</pre>
<p>Note here that the parameter values must appear in the order the parameter
   markers appear in the query. When passing a parameter, you can either specify a
   constant value or a variable. </p>
<p>You may ask why the inconsistency with a different parameter marker from
   <b>sp_executesql</b>? Recall that linked servers in <small class="allcaps">SQL</small> Server are always accessed
   through an <small class="allcaps">OLE DB</small> provider, and <small class="allcaps">OLE DB</small> uses <code>?</code> as
   the parameter marker, a convention inherited from <small class="allcaps">ODBC. OLE DB</small> translates
   that parameter marker as is appropriate for the data source on the other end.
   (Not all <small class="allcaps">RDBMS</small> use @ for variables.) </p>
<p>As with regular <small class="allcaps"><nobr>EXEC()</nobr></small>, you can specify <small class="allcaps">AS USER/LOGIN</small> to use impersonation:</p>
<pre>EXEC('SELECT COUNT(*) FROM ' + @db + '.dbo.sysobjects')
    AS USER = 'davidson' AT SQL2K</pre>
<p>This begs the question: is <b>davidson</b> here a local user or a remote
   user at <small class="allcaps">SQL2K</small>? Books Online is not very clear
   about this, but I did some
   quick experimenting, and found that what you are impersonating is a local user or login,
   not a login on the remote server. (The login to use on the remote server can be
   defined with <b>sp_addlinkedsrvlogin</b>.)</p>
<h2><a name="Common_cases">Common Cases when to (Not) Use Dynamic SQL</a></h2>
<p>When you read the various newsgroups on <small class="allcaps">SQL</small> Server, there is almost every day
   someone who asks a question that is answered with <i>use dynamic <small class="allcaps">SQL</small></i> with a quick example
   to illustrate, but ever so often the person answering forgets to tell
about the implications on permissions or <small class="allcaps">SQL</small> injection. On top of that, far too many
examples use <small class="allcaps"><nobr>EXEC()</nobr></small> without any thought of query plans. And while many of these
   questions taken by the letter have no other answer than dynamic <small class="allcaps">SQL</small>, there is
   often a real business problem which has a completely different solution
   without dynamic <small class="allcaps">SQL</small> – and
   a much better one.</p>
<p>So, in this section I will explore some situations where you <i>could</i> use dynamic
<small class="allcaps">SQL</small>. You will see that sometimes dynamic <small class="allcaps">SQL</small> is a
   good choice, but also that in many cases that it is an outright bad idea. </p>
<h3><a name="Dyn_table">SELECT * FROM @tablename</a></h3>
<p>A common question is why the following does not work: </p>
<pre>CREATE PROCEDURE my_proc @tablename sysname AS
   SELECT * FROM @tablename</pre>

<p>As we have seen, we can make this procedure work with help of dynamic <small class="allcaps">SQL</small>, but
   it should also be clear that we gain none of the advantages with generating
   that dynamic <small class="allcaps">SQL</small> in a stored procedure. You could just as well send the
   dynamic <small class="allcaps">SQL</small> from the client. So, OK: 1) if the
   <small class="allcaps">SQL</small> statement is very complex, you save some network traffic and you do encapsulation.
2) As we have seen, starting with<small class="allcaps"> SQL</small>&nbsp;2005 there are methods to deal with
   permissions. Nevertheless, this<b> is</b> a bad idea.<b> </b> </p>
<p> There seems to be several reasons why people want to parameterise the table
   name. One camp
   appears to be people who are new to <small class="allcaps">SQL</small> programming, but have experience
   from other
languages such as <small class="allcaps">C++, VB</small> etc where parameterisation is a good thing. Parameterising
the table name to achieve generic code and to increase
maintainability seems like good programmer virtue. </p>
<p>But it is just that when it comes to database objects, the old truth does not
hold. In a proper database design, each table is unique, as it describes a
   unique entity. (Or at least it should!) Of course, it is not uncommon to end
   up with a dozen or more look-up tables that all have an id, a name
   column and some auditing columns. But they do describe different entities,
   and their semblance should be regarded as mere chance, and future
   requirements may make the tables more dissimilar.</p>
<p>Furthermore, when it comes to building a query plan, each table has its set
   of statistics and
   presumptions that are by no means interchangeable, as far as <small class="allcaps">SQL</small> Server is
   concerned. Finally, in
   a complex data model, it is important to get a grip of what's being used. When you start to pass table and column names as parameters, you definitely
   lose control.</p>
<p>So if you want to do the above (save the fact that <small class="allcaps">SELECT</small> * should not be
   used in production code), to save some typing, you are on the wrong path. It is
much better to write ten or twenty stored procedures, even if they are similar
to each other. </p>
<p>(If your <small class="allcaps">SQL</small> statements are complex, so that there actually is a considerable
   gain in maintainability to only have them in one place, despite different
   tables being used, you could consider using a
   pre-processor like the one in <small class="allcaps">C/C++</small>. You would still have one set of
   procedures per table, but the code would be in one single include file.)</p>
<h3><a name="Sales_yymm">SELECT * FROM sales + @yymm</a></h3>
<p>This is a variation of the previous case, where there is a suite of tables
   that actually do describe the same entity. All tables have the same columns, and the name includes some partitioning
   component, typically year and sometimes also month. New tables are created as
   a new year/month begins.</p>
<p>In this case, writing one stored procedure per table is not really feasible.
   Not the least, because the user may want to specify a date range for a search, so even
   with one procedure per table you would still need a dynamic dispatcher.</p>
<p>Now, let's make this very clear: this is a flawed
   table design. You should not have one <b>sales</b> table per month, you should
   have one single <b>sales</b> table, and the month that appear in the table
   name, should be the first column of the primary key in the united <b>sales</b> table. But you may be stuck with a legacy
application where you cannot easily change the table design. And, admittedly, there are situations where partitioning
makes sense. The table may be <b><i>huge</i></b> (say over 10 GB
   in size), or you want to be able age to out old data quickly. But in such case you should do partitioning properly.</p>
<p>In the following, I will look at three approaches to deal with partitioning without using dynamic <small class="allcaps">SQL</small>.</p>
<h4>Partitioned Tables</h4>
<p>Partitioned tables were added in <small class="allcaps">SQL</small>&nbsp;2005. You can divide a table in up to 999 partition according to a partition
function. These partitions can be split up over different filegroups to spread out the load. Another important benefit
of partitioned tables is that deleting a partition is a pure meta-data operation, which means that if you want to throw
away all orders that are more than, say, 12 months old, you can do this with the wink of an eye.</p>
<p>Table partitioning is only available in Enterprise and Developer Edition, not in Standard. For this reason, I'm not
going into further details, but refer you to Books Online.</p>
<h4>Views and Partitioned Views</h4>
<p>If you have an old application, where you cannot easily merge the umpteen sales tables into one, because it would break
other parts of the application, a simple approach is
   to define a view like this:</p>
<pre>CREATE VIEW sales AS
   SELECT year = '2006', col1, col2, ... FROM dbo.sales2006
   UNION ALL
   SELECT year = '2005', col1, col2, ... FROM dbo.sales2005
   UNION ALL
   ...  </pre>
<p>&nbsp;Instead of composing
   the table name dynamically, you can now say:</p>
<pre>SELECT ... FROM sales WHERE year = '2006' AND ...</pre>
<p>Also, it's easy to add new tables to the view or remove old tables as the data is aged out. Unfortunately, this view is not terribly efficient, as the query will access
   all tables in the view. Furthermore, the view is not updateable. But with a few more steps, you could make it into what <small class="allcaps">SQL</small> Server
knows as a <em>partitioned view</em>,
a feature added in <small class="allcaps">SQL</small>&nbsp;2000 (and available in all editions of <small class="allcaps">SQL</small> Server). A true partitioned view can be very efficient, because for
   queries that include the partitioning column in the <small class="allcaps">WHERE</small> clause, <small class="allcaps">SQL</small> Server
   will only access the relevant table(s). And such a view is updatable, so you
   can insert data into it, and the data will end up in the right table. </p>
<p>Here is a
   quick example/demo on how to properly set up a partitioned view. Assume that
   as legacy of a poor design we have these three tables: </p>
<pre>SELECT OrderID + 0 AS OrderID, OrderDate, CustomerID, EmployeeID
INTO Orders96 FROM Northwind..Orders WHERE year(OrderDate) = 1996
ALTER TABLE Orders96 ALTER COLUMN OrderID int NOT NULL

SELECT OrderID + 0 AS OrderID, OrderDate, CustomerID, EmployeeID
INTO Orders97 FROM Northwind..Orders WHERE year(OrderDate) = 1997
ALTER TABLE Orders97 ALTER COLUMN OrderID int NOT NULL

SELECT OrderID + 0 AS OrderID, OrderDate, CustomerID, EmployeeID
INTO Orders98 FROM Northwind..Orders WHERE year(OrderDate) = 1998
ALTER TABLE Orders98 ALTER COLUMN OrderID int NOT NULL
go
ALTER TABLE Orders97 ADD CONSTRAINT pk97 PRIMARY KEY (OrderID)
ALTER TABLE Orders96 ADD CONSTRAINT pk96 PRIMARY KEY (OrderID)
ALTER TABLE Orders98 ADD CONSTRAINT pk98 PRIMARY KEY (OrderID)</pre>
<p>First step is to a add <b>Year</b> column to each table. These columns need a
   default (so that processes that insert directly into these tables are
   unaffected) and a <small class="allcaps">CHECK</small> constraint. Here is how it looks for <b>Orders96</b>:</p>
<pre>ALTER TABLE Orders96 ADD Year char(4) NOT NULL
   CONSTRAINT def96 DEFAULT '1996'
   CONSTRAINT check96 CHECK (Year = '1996')</pre>
<p>This column must be the first column in the primary key, so we need to drop
   the current primary key and recreate it:</p>
<pre>ALTER TABLE Orders96 DROP CONSTRAINT pk96
ALTER TABLE Orders96 ADD CONSTRAINT pk96 PRIMARY KEY (Year, OrderID)</pre>
<p>Again, this must be performed for all three tables. Finally, you can create
   the view:</p>
<pre>CREATE VIEW Orders AS
   SELECT * FROM dbo.Orders96
   UNION ALL
   SELECT * FROM dbo.Orders97
   UNION ALL
   SELECT * FROM dbo.Orders98</pre>
<p><b>Note</b>: I have here use <code><nobr>SELECT *</nobr></code> to save some space in the article, but when you 
define your real view, you should list the colunms explicitly. There is a risk that columns could come in different 
order in the tables.</p>
<p>You now have a proper partitioned view that you can perform inserts and updates through. For instance you can run:</p>
<pre>INSERT Orders(Year, OrderID, OrderDate, CustomerID, EmployeeID)
   VALUES ('1997', 12000, '19970101', 'BERGS', 2)</pre>
<p>And if you run a query like:</p>
<pre>SELECT OrderID, OrderDate, EmployeeID
FROM   Orders
WHERE  Year = @year
  AND  CustomerID = N'BERGS'</pre>
<p><small class="allcaps">SQL</small> Server will at run-time only access the OrdersNN table that maps to
   @year. If you look at the query plan casually, it may seem that all three
   tables are
   accessed, but if you check the <b>Filter</b> operators you will find something
   called <small class="allcaps">STARTUP EXPR</small>. This means that <small class="allcaps">SQL</small> Server determines at
   <i>run-time</i>
   whether to access the table or not. (In fact, when I tested this, I only got this result on <small class="allcaps">SQL</small>&nbsp;2005 and <small class="allcaps">SQL</small>&nbsp;2008. On
<small class="allcaps">SQL</small>&nbsp;2000, the start-up expression was not included for some reason I have not been able to understand.)</p>
<p>For your real-world case you may find it prohibitive to change the primary
   key. In this case you could add a <small class="allcaps">UNIQUE</small> constraint with the partitioning
   column + the real primary key. This will not be a proper partitioned view,
   and the view will not be updatable,
   but with some luck <small class="allcaps">SQL</small> Server may still apply start-up expressions, and access only one of the base tables.
   At least I got it to work, when I ran a quick test. You
   should verify that it works for your situation.</p>
<p>When a new table is added with a new year, the view needs to be redefined. If
   this happens frequently, for instance by each month, you should probably set
   up a job for this. I leave out example code, but it requires running
   a cursor over <b>sysobjects</b> to compose a <small class="allcaps">CREATE VIEW</small> statement that you then
   execute with <b>sp_executesql</b> or <small class="allcaps"><nobr>EXEC()</nobr></small>. That would be an example of good use of
   dynamic <small class="allcaps">SQL</small>.</p>
<p>This was a concentrated introduction to partitioned views. You can find the full rules for
   partitioned views under the topic for <small class="allcaps">CREATE VIEW</small> in Books Online. Good
   reading is also Stefan
   Delmarco's detailed article <i>
   <a href="http://www.fotia.co.uk/fotia/FA.02.Sql2KPartitionedViews.01.aspx"><small class="allcaps">SQL</small>
   Server 2000 Partitioned Views</a></i>. </p>
<h4>Compatibility Views</h4>
<p>If you have very many tables, there is a risk that you will hit a roadblock with a partitioned view: <small class="allcaps">SQL</small> Server only
permits 256 tables in a query. Henrik Staun Poulsen suggested an alternate solution that evades this restriction. You first create that new table, with
all the data in it. Then you drop the old tables, but replace them with views:</p>
<pre>CREATE VIEW sales200612 AS
   SELECT col1, col2, col3
   FROM   sales
   WHERE  yearmonth = '200612'</pre>
<p>Old functions that uses dynamic <small class="allcaps">SQL</small> or whatever they do, can continue to do so. If they perform <small class="allcaps">INSERT, UPDATE</small> or
<small class="allcaps">DELETE</small> operations, you need to implement <small class="allcaps">INSTEAD OF</small> triggers to support this.</p>
<p>Obviously, this solution requires you to produce a lot of code, but you don't have to write it by hand; you can
easily write a program in the language of your choice to generate the views and triggers.</p>
<h3><a name="Dyn_update">UPDATE tbl SET @colname = @value WHERE keycol = @keyval</a></h3>
<p>In this case people want to update a column which they select at run time.
The above is actually legal in <small class="allcaps"><nobr>T-SQL</nobr></small>, but what happens is simply that the
   variable @colname
is assigned the value in @value for each affected row in the table. </p>
<p>In this case dynamic <small class="allcaps">SQL</small> would call for the user to have <small class="allcaps">UPDATE</small> permissions
on the table, something not to take lightly. So there is all reason to
avoid it. Here is a fairly simple workaround: </p>
<pre>UPDATE tbl
SET    col1 = CASE @colname WHEN 'col1' THEN @value ELSE col1 END,
       col2 = CASE @colname WHEN 'col2' THEN @value ELSE col2 END,
       ...</pre>
<p>
If you don't know about the <small class="allcaps">CASE</small> expression, please look it up in Books Online.
It's a very powerful <small class="allcaps">SQL</small> feature.</p>
<p>Then again, one would wonder why people want to do this. Maybe it's because their
tables look like this:</p>
<pre>CREATE TABLE products (prodid   prodid_type NOT NULL,
                       prodname name_type   NOT NULL,
                       ...
                       sales_1  money       NULL,
                       sales_2  money       NULL,
                       ...
                       sales_12 money       NULL,
                       PRIMARY KEY (prodid))</pre>
<p>
It could make more sense to move these <i>sales_n</i> columns to a second table: </p>
<pre>CREATE TABLE product_sales (prodid prodid_type NOT NULL,
                            month  tinyint     NOT NULL,
                            sales  money       NOT NULL,
                            PRIMARY KEY (prodid, month))</pre>
<h3><a name="columnalias">SELECT col AS @myname</a></h3>
<p>The request here is to determine the name for a column in a result set at
run-time. My gut reaction, is that this should be handled
client-side. But if your client is a query window is Management Studio or
similar, this is kind of difficult. In any case, this is simple to do without any
dynamic <small class="allcaps">SQL</small> on <small class="allcaps">SQL</small>&nbsp;2005 and later:</p>
<pre>DECLARE @mycolalias sysname
SELECT @mycolalias = 'This week''s alias'

CREATE TABLE #temp (a int NOT NULL,
                    b int NOT NULL)

INSERT #temp(a, b) SELECT 12, 17

EXEC tempdb..sp_rename '#temp.b', @mycolalias, 'COLUMN'

SELECT * FROM #temp</pre>
<p>That is, you first get the data into a temp table, and then you use <b>
sp_rename</b> to rename the column along your needs. (You need to qualify <strong>sp_rename</strong> with tempdb to have
it to operate in that database.) You will get
an informational message <i>Caution: Changing any part of an object name could
break scripts and stored procedures</i>, but you may be able to live with that.
</p>
<p>This trick works on <small class="allcaps">SQL</small>&nbsp;2000 too, although not entirely without dynamic
<small class="allcaps">SQL</small>:
you need put the <small class="allcaps">SELECT</small> from the temp table in
<small class="allcaps"><nobr>EXEC()</nobr></small>:</p>
<pre>EXEC('SELECT * FROM #temp')</pre>
<p>This is because on <small class="allcaps">SQL&nbsp;</small>2000, sp_rename apparently does not trigger a recompile,
so if the the <small class="allcaps">SELECT</small> is in the same batch, the statement fails with <i>Invalid
column name 'b'</i>. There is yet one thing to be aware of on <small class="allcaps">SQL</small>&nbsp;2000: you
cannot use sp_rename in a stored procedure that is to be run by plain users, as sp_rename thinks
you need to be a member of the <b>db_owner</b> or <b>db_ddladmin</b> database roles,
even if this is only a temp table. This issue has been addressed in
<small class="allcaps">SQL</small>&nbsp;2005.</p>
<h3><a name="Dyn_DB">SELECT * FROM @dbname + '..tbl'</a></h3>
<p>In this case the table is in another database which is somehow determined
dynamically. There seems to be several reasons why people want to do this, and
   depending on your underlying reason, the solution is different.</p>
<h4><a name="otherdb">Get Data from another Database</a></h4>
<p>If you for some reason have your
   application spread over two databases, what you absolutely not should do is
   to have code that says:</p>
<pre>SELECT ... FROM <font color="#FF0000">otherdb</font>.dbo.tbl JOIN ...</pre>
<p>This is bad, because if someone asks for a second environment on the same
   server, you have a lot of code to change. </p>
<p>The best solution for this particular problem is to use synonyms, added in <small class="allcaps">SQL</small>&nbsp;2005:</p>
<pre>CREATE SYNONYM otherdbtbl FOR otherdb.dbo.tbl</pre>
<p>You can then refer to <b>otherdb.dbo.tbl</b> as just <b>otherdbtbl</b>. If
   there is a need for a second set of databases, you only have to update the
   synonyms, and there is no need to use dynamic <small class="allcaps">SQL</small>.</p>
<p>Yet a way to avoid dynamic <small class="allcaps">SQL</small> is to use stored procedures for all
   inter-database communication. That is, if you are in <b>db1</b> and need to get data from <b>
   db2</b>, you call a stored procedure in <b>db2</b>. This can be dynamic,
   because <small class="allcaps">EXEC</small> permits you to specify a variable that holds the name of the
   procedure to execute.</p>
<pre>SELECT @dbname = quotename(dbname) FROM ...
SELECT @sp = @dbname + '..some_sp'
EXEC @ret = @sp @par1, @par2...</pre>
<p>If you want to get result sets back from <b>db2</b>, look at my article <i>
   <a href="http://www.sommarskog.se/share_data.html">How to Share Data between Stored Procedures</a></i>
   for suggestions.</p>
<p>There may still be cases you may find that dynamic <small class="allcaps">SQL</small> is the only feasible
   situation. This can be done in two ways. The most obvious
   is:</p>
<pre>SELECT @dbname = quotename(dbname) FROM ...
SELECT @sql = ' SELECT ... FROM ' + @dbname + ' .dbo.otherdbtbl ' +
              ' JOIN dbo.localtbl ... '
EXEC sp_executesql @sql, @params, ...</pre>
<p>But, if the query is complex, and most of the tables are in the remote
   database you can also do:</p>
<pre>SELECT @sql = ' SELECT ... FROM dbo.othertbl ' +
              ' JOIN ' + quotename(db_name()) + '.dbo.localtbl ... '
SELECT @dbname = quotename(dbname) FROM ...
SELECT @sp_executesql = @dbname + '..sp_executesql'
EXEC @sp_executesql @sql, @params, ...</pre>
<p>As above, I make use of that you can specify the procedure name dynamically
   with <small class="allcaps">EXEC</small>. The trick here is that when you specify a system stored procedure
   in three-part notation with the database name, the procedure executes in the
   context of that database. Thus, the dynamic <small class="allcaps">SQL</small> in this example runs in
   @dbname, not the current database.</p>
<h4><a name="everydb">Do Something in Every Database</a></h4>
<p>This sounds to me like some sysadmin
   venture, and for sysadmin tasks dynamic <small class="allcaps">SQL</small> is
   usually a fair game, because neither caching nor permissions are issues.
   Nevertheless there is an kind of alternative: <b>sp_MSforeachdb</b>, demonstrated by this example: </p>
<pre>sp_MSforeachdb 'SELECT ''?'', COUNT(*) FROM sysobjects'</pre>
<p>As you might guess, <b>sp_MSforeachdb</b> uses dynamic <small class="allcaps">SQL</small> internally, so
   what you win is that you don't have to write the control loop yourself. I should
   hasten to add that <b>sp_MSforeachdb</b> is not documented in Books Online,
   which also means that use of it is not supported by Microsoft and it could be
   changed or withdrawn from <small class="allcaps">SQL</small> Server without notice.</p>
<h4><a name="masterdb">A "Master" Database</a></h4>
<p>The scenario here is that you have a suite of databases with identical
   schema. The typical reason they are different databases and not one, is that every
   database serves a different customer, and each customer can access his
   database (but of course no one else's). Some people
   see a problem with the same stored procedures in fifty databases,
   and believe that they face a maintenance nightmare. So they get the idea
   that they should put the procedures in a "master" database. Yes, you can do that. It
   will give you a much bigger maintenance problem, because your code will
   entirely littered with dynamic <small class="allcaps">SQL</small>.
   In fact, if you feel that this is the only alternative, you are better off
   skipping stored procedures altogether and do all access from client code
   instead. In such case there is only one place you need to specify the
   database: the connection string.</p>
<p>What else can you do? Some people might suggest that you should collapse the
   databases into one, and employ a strict
   row-level security scheme. Personally, I would never accept such a solution
   as a potential customer. In a complex application, bugs can easily lead to
   that information is exposed to people who should not see it. Besides,
   row-level security cannot be implemented entirely waterproof in <small class="allcaps">SQL</small> Server.
   Whereas queries only would return the data they should, query plans and error
   messages may indirectly disclose information to users who are not authorised
   to see it.</p>
<p>Another wild approach is to use <small class="allcaps">SQL</small> Server's own <b>master</b> database and install the application procedures
   as system procedures. I have not played with this for a long time, but I am told that it still works in <small class="allcaps">SQL</small>&nbsp;2008. In any case, this is entirely
   unsupported. So while I mention the possibility, I don't give you the details
   on how to do it and I strongly recommend that you don't go there.</p>
<p>What then is the real solution? Install the stored procedures in each database and develop
   rollout routines for your <small class="allcaps">SQL</small> objects. You need this anyway, the day you want
   to update the table definitions. This also permits you to have some
   flexibility. Some customers may prefer to skip an upgrade. Other customers
   may be prepared to pay for extra functions that only they have access to. Even more importantly, it permits you to easily scale out and move some
   databases to a second server. I mentioned that as a customer, I would not
   accept to share database with other customers. In fact, a security-aware
   customer would not even accept to share the same instance of <small class="allcaps">SQL</small> Server, but
   require his own instance.</p>
<p>(You may ask whether not synonyms could be used to implement the "master"
   database. I have not been able to think of anything useful, but if you find
   out something, please drop me a line.)</p>
<h3><a name="createotherdb">Creating an Object in Another Database</a></h3>
<p>This question sometimes comes up. Most often people have problems with the
   <small class="allcaps">USE</small> command. The correct solution is to avoid <small class="allcaps">USE</small> altogether in this case. In
   fact, we have already seen how to do this:</p>
<pre>SELECT @sql = 'CREATE VIEW ...'
SELECT @sp_executesql = quotename(@dbname) + '..sp_executesql'
EXEC @sp_executesql @sql</pre>
<p>That is, make use of that you can set the database context by calling <b>sp_executesql</b> with three-part notation.</p>
<h3><a name="List">SELECT * FROM tbl WHERE col IN (@list)</a></h3>
<p>It is fascinating how may people who put '1,2,3,4' in @list, and then are
   puzzled why the query above does not return any rows. Well, if there is a row
   where <b>col</b> has the value '1,2,3,4', you will get a match. These two
   conditions are the same:</p>
<pre>col IN (@list)
col = @list</pre>
<p><small class="allcaps">IN</small> does <i><b>not</b></i> mean "parse whatever data there is at runtime as a
   comma-separated list". It's a <i><b>compile-time </b></i>shortcut for
   <code>col =
   @a OR col = @b OR</code> ...</p>
<p>This is a very common question on the newsgroups, and <i>Use dynamic <small class="allcaps">SQL</small></i> is a far too common answer.
   Yes, you can do this with dynamic <small class="allcaps">SQL</small>, but it is an extremely poor solution.
   You cannot pass the list as a parameter to <b>sp_executesql</b>, so you would have
   to use <small class="allcaps"><nobr>EXEC()</nobr></small> and be open to <a href="http://www.sommarskog.se/dynamic_sql.html#SQL_injection"><small class="allcaps">SQL</small> injection</a>. On
   top of that, for long lists, <small class="allcaps">IN</small> has extremely poor performance – in some
   tests I did, it took <small class="allcaps">SQL</small> Server 15 seconds to build the query plan for a list
   with 10000 elements.</p>
<p>The correct method is to unpack the list into a table with a user-defined
   function or a stored procedure. In my article, <i><a href="http://www.sommarskog.se/arrays-in-sql.html">Arrays and Lists in
 <small class="allcaps">SQL</small> Server</a></i>, I describe a whole range of ways to do this. I also present performance data for the various methods. (Dynamic <small class="allcaps">SQL</small> is at
 the bottom of that list!) This is a long article, but there are jump-start
   links in the beginning of the article, depending on which version of <small class="allcaps">SQL</small>
   Server you are using.</p>
<h3><a name="Condition">SELECT * FROM tbl WHERE @condition</a></h3>
<p>If you are considering to write the procedure</p>
<pre>CREATE PROCEDURE search_sp @condition varchar(8000) AS
   SELECT * FROM tbl WHERE @condition</pre>
<p>Just forget it. If you are doing this, you have not completed the transition
   to use stored procedure and you are still assembling your <small class="allcaps">SQL</small> code in the client.
But this example lapses into</p>
<h3><a name="Dyn_search">Dynamic Search Conditions</a></h3>
<p>A not too uncommon case is that the users should be able to select data from a broad set of
parameters. The procedure <b>search_orders</b> in the section on
   <a href="http://www.sommarskog.se/dynamic_sql.html#SQL_injection"><small class="allcaps">SQL</small> injection</a>
   is a very simple example of this.</p>
<p>Any programmer that tackles this realises that writing a static solution
   with a tailor-made query for each combination of input parameters is
   impossible. It most cases, it's simple to write a single static query with conditions like:</p>
<pre>AND (CustomerID = @custid OR @custid IS NULL)</pre>
<p>But in <span class="allcaps">SQL&nbsp;</span>2005 and earlier if is not possible to get good performance from such a query, but the only option for good
  performance is to use dynamic <small class="allcaps">SQL</small>. This changed in <span class="allcaps">SQL&nbsp;</span>2008, provided that you use the <span class="allcaps">RECOMPILE</span> hint. However that is a bit complicated, because the original implementation had a serious bug, so Microsoft reverted on that change for a while. Rather than going into details here, I refer you to my article, <i><a href="http://www.sommarskog.se/dyn-search.html">Dynamic Search Conditions</a>,</i> where I
   discuss this type of searches in more detail and where I present several methods, both with dynamic <small class="allcaps">SQL</small> and
   static <small class="allcaps">SQL. </small>This article exists in two versions, one for
  <a href="http://www.sommarskog.se/dyn-search-2008.html"><small class="allcaps">SQL</small>&nbsp;2008 and later</a>, and one <a href="http://www.sommarskog.se/dyn-search-2005.html">for earlier versions</a>.</p>
<h3><a name="Crosstab">Dynamic Crosstab</a></h3>
<p>Another common request is to make a dynamic crosstab query, where you transform rows into columns. For instance, say
that you want to display the number of orders handled by each employee in Northwind with one column per year. This query
works well:</p>
<pre>SELECT E.LastName,
       [1996] = SUM(CASE Year(OrderDate) WHEN '1996' THEN 1 ELSE 0 END),
       [1997] = SUM(CASE Year(OrderDate) WHEN '1997' THEN 1 ELSE 0 END),
       [1998] = SUM(CASE Year(OrderDate) WHEN '1998' THEN 1 ELSE 0 END)
FROM   Orders O
JOIN   Employees E ON O.EmployeeID = E.EmployeeID
GROUP  BY E.LastName</pre>
<p>But in many situations you don't exactly which columns you will have in the data, or even how many there will be. For
instance, in this example, we may not know beforehand for which years there are orders. </p>
<p>One approach is to set an upper limit of how many output columns you support and use dummy names for the columns.
Once you have run the query, you use the technique I described in the section <a href="http://www.sommarskog.se/dynamic_sql.html#columnalias"><small class="allcaps">SELECT</small> col AS @myname</a>.
</p>
<p>However, in the very most cases, you will want to employ dynamic <small class="allcaps">SQL</small> for this. And there is not really any
alternative. A <small class="allcaps">SELECT</small> statement returns a table, and a table has a known number of columns with known names, so there is
no way you can write a static <small class="allcaps">SELECT</small> statement to achieve this. </p>
<p>The general technique is a two-step operation: 1) Get the unique values to pivot on. 2) with those values, generate a query like the one above. While it's a short description, it
takes some time to get everything in place. You can make a shortcut with the stored procedure 
<a target="_blank" type="text/plain" href="http://www.sommarskog.se/pivot_sp.sp">pivot_sp</a>, something I have adapted from a procedure 
originally written by <small class="allcaps">SQL</small>
Server <small class="allcaps">MVP</small> Itzik Ben-Gan. The procedure takes a number of parameters permitting you to specify the query, the rows to group
by and to pivot by, and which aggregation operation you want. </p>
<p>As this article is already long enough, I don't go into details to try to explain how it works, but leave it to you 
to explore it on your own. I like to stress one thing though: The way <b>pivot_sp</b> is written, it is wide-open to
<small class="allcaps">SQL</small> injection, and it is very difficult, not to say impossible to make the procedure 
fool-proof since it accepts query text as parameter. This is no problem as long as you use it as your own utility 
procedure and have full control over the input, but you should not make a procedure like this one accessible to anyone. 
Rather I recommend that you do </p>
<pre>DENY EXECUTE ON pivot_sp TO public</pre>
<p>To make sure that plain users cannot run it. If you make a call to <b>pivot_sp</b> in a stored procedure, this call 
will succeed as ownership chaining applies. The file for <a target="_blank" type="text/plain" href="http://www.sommarskog.se/pivot_sp.sp">
pivot_sp</a> includes an example to demonstrate this.</p>
<p>Another option for dynamic crosstab is <a href="http://www.rac4sql.net/"><small class="allcaps">RAC</small></a>, which is a third-party tool. I have never used it
myself, but I have heard several good comments about it.</p>
<h3><a name="Order_by">SELECT * FROM tbl ORDER BY @col</a></h3>
<p>This can easily be handled without dynamic <small class="allcaps">SQL</small> in this way:</p>
<pre>SELECT col1, col2, col3
FROM   dbo.tbl
ORDER  BY CASE @col1
               WHEN 'col1' THEN col1
               WHEN 'col2' THEN col2
               WHEN 'col3' THEN col3
           END</pre>
<p>Again, review the <small class="allcaps">CASE</small> expression in Books Online, if you are not acquainted
with it. </p>
<p>Note that if the columns have different data types you cannot lump them into
   the same <small class="allcaps">CASE</small> expression, as the data type of a <small class="allcaps">CASE</small>
   expression is always one and the same. Instead, you can do this:</p>
<pre>SELECT col1, col2, col3
FROM   dbo.tbl
ORDER  BY CASE @col1 WHEN 'col1' THEN col1 ELSE NULL END,
          CASE @col1 WHEN 'col2' THEN col2 ELSE NULL END,
          CASE @col1 WHEN 'col3' THEN col3 ELSE NULL END</pre>
<p>
If you also want to make it dynamic whether the order should be ascending or
descending, add one more <small class="allcaps">CASE</small>:</p>
<pre>SELECT col1, col2, col3
FROM   dbo.tbl
ORDER  BY CASE @sortorder
               WHEN 'ASC' THEN CASE @col1
                                    WHEN 'col1' THEN col1
                                    WHEN 'col2' THEN col2
                                    WHEN 'col3' THEN col3
                                END
               ELSE NULL
           END ASC,
           CASE @sortorder
               WHEN 'DESC' THEN CASE @col1
                                     WHEN 'col1' THEN col1
                                     WHEN 'col2' THEN col2
                                     WHEN 'col3' THEN col3
                                 END
               ELSE NULL
           END </pre>
<p>Or use the form in the second example to deal with different data types.</p>
<p><small class="allcaps">SQL</small> Server <small class="allcaps">MVP</small> Itzik Ben-Gan had a good article on this topic in the March
2001 issue of <a href="http://www.sqlmag.com/"><small class="allcaps">SQL</small> Server Magazine</a>,
where he offers other suggestions.</p>
<p>It should be added that these solutions has the disadvantage that they will always cause a sort which for a large
data set could be expensive. If you add an <small class="allcaps">ORDER BY</small> clause in dynamic <small class="allcaps">SQL</small>, the optimizer may avoid the sort if there is
a suitable index.</p>
<h3><a name="Top">SELECT TOP @n FROM tbl</a></h3>
<p>This is no longer an issue, since <small class="allcaps">SQL</small>&nbsp;2005 added new syntax that permits a variable:</p>
<pre>SELECT TOP(@n) col1, col2 FROM tbl</pre>
<p>On <small class="allcaps">SQL</small>&nbsp;2000, <small class="allcaps">TOP</small> does not accept variables, so you need to use dynamic <small class="allcaps">SQL</small> to use
<small class="allcaps">TOP</small>. But there is an alternative:</p>
<pre>CREATE PROCEDURE get_first_n @n int AS
SET ROWCOUNT @n
SELECT au_id, au_lname, au_fname
FROM   authors
ORDER  BY au_id
SET ROWCOUNT 0</pre>
<p>It can be disputed whether <small class="allcaps">SET ROWCOUNT</small> @n is really a better solution than
   running a dynamic <small class="allcaps">SQL</small> statement with <small class="allcaps">TOP. A</small> dynamic <small class="allcaps">TOP</small> is probably a
   better choice, as long as you can accept the security implications. (But it's
   not worth to change the permissions only for this.)</p>
<p>I guess a common reason for wanting to do this is to implement paging in web
   applications. <small class="allcaps">SQL</small> Server <small class="allcaps">MVP</small> Aaron Bertrand has an article which is the
   <a href="http://www.aspfaq.com/show.asp?id=2120">standard reference</a> on
   this topic. </p>
<h3><a name="Cre_tbl">CREATE TABLE @tbl</a></h3>
<p>The desire here is to create a table of which the name is determined at
   run-time.</p>
<p>If we just look at the arguments against using dynamic <small class="allcaps">SQL</small> in stored
   procedures, few of them are really applicable here. If a stored procedure has a
   static <small class="allcaps">CREATE TABLE</small> in it, the user who runs the procedure must have
   permissions to create tables, so dynamic <small class="allcaps">SQL</small>
   will not change anything. Plan caching obviously has nothing to do with
   it. Etc.</p>
<p>Nevertheless: <i> <b>Why? Why would you want to do this?</b></i> If you are creating tables on the fly in your
   application, you have missed some fundamentals about database design. In a
   relational database, the set of tables and columns are supposed to be
   constant. They may change with the installation of new versions, but not during
   run-time. </p>
<p>Sometimes when people are doing this, it appears that they want to construct
unique names for temporary tables. This is completely unnecessary, as this is a
built-in feature in <small class="allcaps">SQL</small> Server. If you say:</p>
<pre>CREATE TABLE #nisse (a int NOT NULL)</pre>
<p>then the actual name behind the scenes will be something much longer, and no
other connections will be able to see this instance of <b>#nisse</b>.</p>
<p>If you want to create a permanent table which is unique to a user, but you
   don't want to stay connected and therefore cannot use temp tables, it may be
better to create one table that all clients can share, but where the first
column is a key which is private to the client. I discuss this method a little
   more closely in my article <i><a href="http://www.sommarskog.se/share_data.html#prockeyed">How to
   Share Data between Stored Procedures</a></i>.</p>
<h3><a name="unknowncolumns">CREATE TABLE with Unknown Columns</a></h3>
<p>Sometimes I see persons on the newsgroups that are unhappy, because they
 create a temp table from dynamic <small class="allcaps">SQL</small>, and then they can't access it, because it
 disappeared when the dynamic <small class="allcaps">SQL</small> exited. When told that they have to create the
 table outside the dynamic <small class="allcaps">SQL</small>, they respond that they can't, because they don't
 know the structure of the table until run-time.</p>
<p>One solution is to create a global temp table, one with two # in the name,
 for instance <b>##temp</b>. Such a table is visible to all processes (so you may have
 to take precautions to make the name unique), and unless you explicitly drop it, it exists
 until your process exits.</p>
<p>But the real question is: <i> <b>what are these guys up to?</b></i> If you are
   working with a relational database, and you don't know the structure of your
   data until run-time, then there is something fundamentally wrong. As I have
   never been able to fully understand what the underlying business requirements
   are, I can't really provide any alternatives. But I would suggest that if you
   need to go this road, you should seriously consider to run your <small class="allcaps">SQL</small> from a client
   program. Because, all access
   to that table would have to be through dynamic <small class="allcaps">SQL</small>, and composing
   dynamic <small class="allcaps">SQL</small> strings is easier in languages with better string capabilities,
   be that <small class="allcaps">C#, VB</small> or Perl. </p>
<h3><a name="linkservers">Linked Servers</a></h3>
<p>This is similar to parameterising the <a href="http://www.sommarskog.se/dynamic_sql.html#Dyn_DB">database name</a>,
   but in this case we want to access a linked server of which the name is
   determined at run-time.</p>
<p> Two of the solutions for dynamic database names apply here as well:</p>
<ul>
   <li>On <small class="allcaps">SQL</small>&nbsp;2005 and later, the best solution is probably to use synonyms:
      <pre>CREATE SYNONYM myremotetbl FOR Server.db.dbo.remotetbl</pre></li>
   <li>If you can confine the access to the linked server to a stored procedure
      call, you can build the SP name dynamically:
<pre>SET @sp = @server + 'db.dbo.some_sp'
EXEC @ret = @sp @par1, @par2...</pre></li>
</ul>
<p>
If you want to join a local table with a remote table on some remote server,
determined in the flux of the moment, dynamic <small class="allcaps">SQL</small> is probably the best way if
you are on <small class="allcaps">SQL</small>&nbsp;2000.
There exists however an alternative, although it's only usable in some
situations. You can use <b>sp_addlinkedserver</b> to define the linked server at
run-time,
as demonstrated by this snippet:</p>
<pre>EXEC sp_addlinkedserver MYSRV, @srvproduct='Any',
                               @provider='SQLOLEDB', @datasrc=@@SERVERNAME
go
CREATE PROCEDURE linksrv_demo_inner WITH RECOMPILE AS
   SELECT * FROM MYSRV.master.dbo.sysdatabases
go
EXEC sp_dropserver MYSRV
go
CREATE PROCEDURE linksrv_demo @server sysname AS
   IF EXISTS (SELECT * FROM master..sysservers WHERE srvname = 'MYSRV')
      EXEC sp_dropserver MYSRV
   EXEC sp_addlinkedserver MYSRV, @srvproduct='Any',
                           @provider='SQLOLEDB', @datasrc=@server
   EXEC linksrv_demo_inner
   EXEC sp_dropserver MYSRV
go
EXEC linksrv_demo 'Server1'
EXEC linksrv_demo 'Server2'</pre>
<p>
There are two procedures. <b>linksrv_demo_inner</b> is the procedure where we
actually access the linked server. As the linked server must exist when the
procedure is created, I first create a dummy entry for <small class="allcaps">MYSRV</small>, which I subsequently
drop once the procedure has been created. (Not only must the linked server exist, it must also have the database and
tables that you access.) <b>linksrv_demo</b> is the outside interface which takes a
server name as a parameter, and then at run-time defines <small class="allcaps">MYSRV</small> to point to
@server.</p>
<p>
The above is only possible under certain conditions:</p>
<ul>
   <li>The procedure must be run by someone who has privileges to set up
    linked servers, normally only the roles <b>sysadmin</b> and <b>setupadmin</b>
    have these permissions. Thus, plain users do not apply.</li>
    <li>Since you change a
     server-wide definition, you cannot have several instances of the procedure
     running. (It goes without saying, that you should use the alias in this
       procedure only.)</li>
</ul>
<p>
As you can see in the example, I've added <small class="allcaps">WITH RECOMPILE</small> to <b>linksrv_demo_inner</b>.
This is a safety precaution, to prevent that a cached plan does not access a
different server. I don't think this is really necessary, as <small class="allcaps">SQL</small> Server should sense the
changed definition. In fact, you may not even have to split the code over two
procedures, but as they say, better safe than sorry.</p>
<h3><a name="OPENQUERY">OPENQUERY</a></h3>
<p>The rowset functions <small class="allcaps">OPENQUERY</small> and <small class="allcaps">OPENROWSET</small> often calls for dynamic <small class="allcaps">SQL</small>. Their second argument
    is an <small class="allcaps">SQL</small> string, and they do no accept variables.
   (This is because the optimizer builds a plan for the distributed query when
   the procedure is compiled.) So any single parameter you want to pass to the
   <small class="allcaps">SQL</small> statement for that remote server requires you to use dynamic <small class="allcaps">SQL</small>. Since the
   remote <small class="allcaps">SQL</small> string can include string literals, you
   may have to deal with up to three
   levels of nested quotes. If you don't watch out, you can spend a full day
   looking at things like:</p>
<pre>DECLARE @sql varchar(8000)
SELECT @sql = 'SELECT * FROM OPENQUERY(MYSRV, ' +
              '''SELECT * FROM Northwind.dbo.Orders ' +
              'WHERE CustomerID = N''''VINET'''''')'
PRINT @sql
EXEC(@sql)</pre>
<p>to try to find out if you might you have one <code>'</code> too many or too
   few. </p>
<p>Strict discipline is absolutely necessary when working with dynamic <small class="allcaps">SQL</small> for
   <small class="allcaps">OPENQUERY</small>. The function <a href="http://www.sommarskog.se/dynamic_sql.html#quotestring"><b><nobr>quotestring()</nobr></b></a>
   that I showed you earlier can be of great help:
</p>
<pre>DECLARE @remotesql nvarchar(4000),
        @localsql  nvarchar(4000),
        @state     char(2)

SELECT @state = 'CA'
SELECT @remotesql = 'SELECT * FROM pubs.dbo.authors WHERE state = ' +
                     dbo.quotestring(@state)
SELECT @localsql  = 'SELECT * FROM OPENQUERY(MYSRV, ' +
                     dbo.quotestring(@remotesql) + ')'

PRINT @localsql
EXEC (@localsql)</pre>
<p>The built-in function <b><nobr>quotename()</nobr></b> is usually not useful here, as the <small class="allcaps">SQL</small> statement easily
   can exceed the limit of 129 characters for the input parameter to <b>
   <nobr>quotename()</nobr></b>.
</p>
<p>On <small class="allcaps">SQL</small>&nbsp;2005 and later, you can use <small class="allcaps"><nobr>EXEC()</nobr></small> to run an <small class="allcaps">SQL</small> statement on a
   <a href="http://www.sommarskog.se/dynamic_sql.html#EXECatlinked">linked
   server</a>. Since <small class="allcaps"><nobr>EXEC()</nobr></small> at linked servers can take parameters, this can make
   things considerably easier. Then again, you can join <small class="allcaps">OPENQUERY</small> with local
   tables, so that only rows of interest are brought across the wire. This you
   cannot do with <small class="allcaps"><nobr>EXEC()</nobr></small>.</p>
<h3><a name="Col_width">Dynamic Column Widths</a></h3>
<p>Say that you write a stored
   procedure that is to present some data, and the <small class="allcaps">GUI</small> it is to be run from is
   Query Analyzer or <small class="allcaps">SQL</small> Server Management Studio (presumably because it is a sysadmin procedure). To make the
   output easy to digest, you want the column width to be so wide that no data
   is truncated, but neither do you want any extraneous spaces. This is
   something you can achieve with dynamic <small class="allcaps">SQL</small>. Typically you would use a temp table
   to hold the data, in which case there are no permission issues. </p>
<p>Rather than giving an example, I refer you to the source code for the popular (but undocumented)
   system procedure <b>sp_who2</b>. You can find the code by entering <b>exec
   master..sp_helptext sp_who2</b>.</p>
<h3><a name="maintenancetasks">Dynamic SQL and Maintenance Tasks</a></h3>
<p>I've written this text with a main focus on application code, because it is
   mainly in application tasks, bad usage of dynamic <small class="allcaps">SQL</small> can cause serious harm
   by opening for <a href="http://www.sommarskog.se/dynamic_sql.html#SQL_injection"><small class="allcaps">SQL</small> injection</a>, poor
   <a href="http://www.sommarskog.se/dynamic_sql.html#queryplans">query-plan reuse</a>, and result in code that is
   difficult to read and maintain.</p>
<p>Here, I like to briefly discuss code is for maintenance jobs, code that
   runs once a
   night or once a week or even less frequently. Generally, for this sort of
   code, dynamic <small class="allcaps">SQL</small> is almost always a fair game. Query
   plans are rarely an issue. And if the code is to be run by users with <b>
   sysadmin</b> privileges, there are no permissions issues. The same applies to
   code that does not require permissions outside the database, and is to be run
   by users with <b>db_owner</b> privileges.</p>
<p>There are however, two points about <small class="allcaps">SQL</small> injection I like to make.</p>
<ol>
   <li>If you are a <small class="allcaps">DBA</small> that writes some stored procedure to be run by junior
   operators that do not have <b>sysadmin</b> privilege themselves, you must of
   course take precaution against <small class="allcaps">SQL</small> injection, so that they don't outsmart
   you.</li>
   <li>If you write a job that performs operations on tables in
   every database, be careful to use <nobr><b>quotename()</b></nobr> when you build the <small class="allcaps">SQL</small> strings.
   This is particularly important if there are non-sysadmin users that own
   databases. A user could create a table with a name that injects an <small class="allcaps">SQL</small> command
      into
   your maintenance script when you run it. If you are the <small class="allcaps">DBA</small> at a hosting
   company, this is a risk that you definitely should not neglect.</li>
</ol>
<h2><a name="Feedback">Acknowledgements and Feedback</a></h2>
<p>I like to thank the following persons who have provided valuable suggestions
   and input for this article: <small class="allcaps">SQL</small> Server MVPs Tibor Karaszi, Keith Kratochvil,
   Steve Kass, Umachandar Jaychandran, Hal Berenson and Aaron Bertrand, as well as Pankul Verma,
   Anthony Faull, Henrik Staun Poulsen, Karl Jones, Marcus
   Hansfeldt, Gennadi Gretchkosiy, Jeremy Lubich and Simon Hayes. I also like to thank Frank Kalis for providing the
<a href="http://www.insidesql.org/beitraege/entwicklung/dynamisches-sql-fluch-und-segen">German</a>
   translation.</p>
<p>Not the least I like to thank all you people who have pointed out typos
and spelling errors. Just keep those letters and cards coming!</p>
<p>If you have suggestions for improvements or corrections on contents, language or
formatting, please mail me at <a href="mailto:esquel@sommarskog.se">
   esquel@sommarskog.se</a>.
If you have technical questions that any knowledgeable person could answer, I encourage you to
post to any of the newsgroups <a href="news:microsoft.public.sqlserver.programming">microsoft.public.sqlserver.programming</a> or <a href="news:comp.databases.ms-sqlserver">comp.databases.ms-sqlserver</a>.</p>
<h2><a name="revisions">Revision History</a></h2>
<p><b>2011-06-23</b> – Updated the text in the section on <a href="http://www.sommarskog.se/dynamic_sql.html#Dyn_search">Dynamic Search Conditions</a> to mention the RECOMPILE hint, since the bug mentioned in the entry from 2009-02-14 has been fixed.</p>
<p><b>2009-09-12</b> – Gennadi Gretchkosiy pointed out using that <code><nobr>SELECT *</nobr></code> in a 
  partitioned view is not OK. If the columns come in different order in the underlying tables, you will get a mess.</p>
<p><b>2009-02-14</b> - Removed text in the section on <a href="http://www.sommarskog.se/dynamic_sql.html#Dyn_search">Dynamic Search Conditions</a> that referred 
to the new behaviour of <small class="allcaps">OPTION (RECOMPILE)</small> in SQL 2008, that Microsoft is now reverting 
on because of a <a href="https://connect.microsoft.com/SQLServer/feedback/ViewFeedback.aspx?FeedbackID=386810">serious 
bug</a>.</p>
<p><b>2008-12-06</b> – Modified the section on <a href="http://www.sommarskog.se/dynamic_sql.html#Crosstab">dynamic crosstab</a> to stress that pivot_sp is 
open to <small class="allcaps">SQL</small> injection.</p>
<p><b>2008-12-02</b> – Updated the article for <small class="allcaps">SQL</small>&nbsp;2008. Rewrote the section on <a href="http://www.sommarskog.se/dynamic_sql.html#Sales_yymm">Sales + @yymm
tables</a> and added one more approach. Added a section on <a href="http://www.sommarskog.se/dynamic_sql.html#Crosstab">dynamic crosstab</a>. Various other minor
changes. </p>
<p><b>2008-06-06</b> – Added an example on how to deal with dynamic sort
order in the section on <small class="allcaps"><a href="http://www.sommarskog.se/dynamic_sql.html#Order_by">ORDER BY</a></small>.</p>
<p><b>2008-03-18</b> – Added a section on how to handle a
<a href="http://www.sommarskog.se/dynamic_sql.html#columnalias">dynamic column alias</a>.</p>
<p><b>2006-12-27</b> – In the section <i><a href="http://www.sommarskog.se/dynamic_sql.html#queryplans">Caching
   Query Plans</a></i>, added a note
   on forced parameterisation and a demo of the performance penalty for failing
   to use parameterised queries.</p>
<p><b>2006-07-25</b> – Corrected syntax in example with <a href="http://www.sommarskog.se/dynamic_sql.html#cursor0">
   cursor variable</a> after comment from Anthony Faull.</p>
<p><b>2006-04-23</b> – Thoroughly reworked the article to cover <small class="allcaps">SQL</small>&nbsp;2005 in
   full, resulting in lots of new text, lots of old text dropped, and many
   sections rearranged. I'm now
   more strongly favouring <b>sp_executesql</b> over <small class="allcaps"><nobr>EXEC()</nobr></small>, and
   I put more stress on <small class="allcaps">SQL</small>
   injection. I also stress the importance of using parameterised statements for
   query-plan reuse, and I note that prefixing with <b>dbo</b> is essential for
   query-plan reuse. The examples of cases where (not) to use dynamic <small class="allcaps">SQL</small> have
   had an overhaul as well, if not equally drastic. I'm now giving a very quick
   example of partitioned views for the sales + @yymm case. The article now also
   includes snippets for
   parameterised commands from VB6 and VB .Net.</p>
<p><b>2005-04-17</b> – Added <a href="http://www.sommarskog.se/dynamic_sql.html#sp_executesqlong">example</a> of <small class="allcaps">EXEC</small> + <b>
   sp_executesql</b> with <small class="allcaps">OUTPUT</small> parameter. Added use of <b>nvarchar(max) </b>on
   <small class="allcaps">SQL</small>&nbsp;2005 for <a href="http://www.sommarskog.se/dynamic_sql.html#quotestring">quotestring</a> and elsewhere.</p>
<p><b>2004-02-08</b> –
   <a href="http://www.insidesql.org/beitraege/entwicklung/dynamisches-sql-fluch-und-segen">German</a> translation now available. Minor language corrections.</p>
<p><b>2003-12-02</b> – Added example of using
   <a href="http://www.sommarskog.se/dynamic_sql.html#cursor0">cursor</a> variable with dynamic <small class="allcaps">SQL</small>. Modified description
   of first parameter to <a href="./The curse and blessings of dynamic SQL_files/The curse and blessings of dynamic SQL.htm"><b>sp_executesql</b></a>.</p>
<p align="right"><a href="http://www.sommarskog.se/index.html">Back to my home page</a>.</p>



</body></html>